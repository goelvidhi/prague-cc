<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="exp" docName="draft-briscoe-iccrg-prague-congestion-control-00"
     ipr="trust200902" updates="">
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
       full title is longer than 39 characters -->

    <title abbrev="Prague Congestion Control">Prague Congestion
    Control</title>

    <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
      <organization>Nokia Bell Labs</organization>

      <address>
        <postal>
          <street/>

          <city>Antwerp</city>

          <country>Belgium</country>
        </postal>

        <email>koen.de_schepper@nokia.com</email>

        <uri>https://www.bell-labs.com/usr/koen.de_schepper</uri>
      </address>
    </author>

    <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
      <organization>Nokia Bell Labs</organization>

      <address>
        <postal>
          <street/>

          <city>Antwerp</city>

          <country>Belgium</country>
        </postal>

        <email>olivier.tilmans@nokia-bell-labs.com</email>
      </address>
    </author>

    <author fullname="Bob Briscoe" initials="B." role="editor"
            surname="Briscoe">
      <organization>Independent</organization>

      <address>
        <postal>
          <street/>

          <country>UK</country>
        </postal>

        <email>ietf@bobbriscoe.net</email>

        <uri>http://bobbriscoe.net/</uri>
      </address>
    </author>

    <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
      <organization>Independent</organization>

      <address>
        <postal>
          <street/>

          <country>Norway</country>
        </postal>

        <email>me@asadsa.com</email>
      </address>
    </author>

    <date month="" year=""/>

    <area>IRTF</area>

    <workgroup>Internet Congestion Control Research Group (ICCRG)</workgroup>

    <keyword>Internet-Draft</keyword>

    <keyword>I-D</keyword>

    <abstract>
      <t>{ToDo, something like:} This Informational/experimental RFC describes
      the Prague congestion control scheme, derived from DCTCP and adapted for
      Internet traffic by fulfilling the L4S Prague requirements. It reuses
      the DCTCP mechanisms to achieve high-burst tolerance, low latency, and
      high throughput on L4S supporting network nodes. Prague TCP is intended
      to be deployed on the Internet where it is compatible with TCP-Reno on
      drop based bottlenecks (AQM, policers or taildrop) and with L4S network
      support also on ECN based bottlenecks. Prague TCP can only achieve its
      low latency and high throughput when its packets are marked with a
      shallow ECN threshold and can only achieve its throughput fairness when
      a Coupled or FQ AQM mechanism is in place. For Classic ECN bottlenecks
      (RFC...) that are unaware of L4S, operators might want to apply
      additional measures to limit or avoid the higher throughput use of L4S
      Prague traffic. This memo presents the current state of the Linux Prague
      TCP implementation and some possible opprtunities for further
      performance improvements.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="pracc_intro" title="Introduction">
      <t>{ToDo: Copy largely from netdev Prague paper (not too elaborate)}</t>

      <section title="Maturity Status (To be Removed Before Publication)">
        <t>The field of congestion control is always a work in progress.
        However, there are areas of the Prague CC that are not yet even be
        complete. And in other implementations of the Prague CC, other areas
        are incomplete. In the Linux reference implementation of TCP Prague,
        interim code is used in these incomplete areas. They are:<list
            style="symbols">
            <t>Flow start and restart (standard slow start is used, even
            though it often exits early in L4S environments were ECN marking
            tends to be frequent);</t>

            <t>Faster than additive increase (standard additive increase is
            used, which makes the flow particularly sluggish if it has dropped
            out of slow start early).</t>
          </list>The body of this document describes the Prague CC as
        implemented (primarily in the Linux reference implementation, but also
        notes on other implementations are sometimes given). Any non-default
        options or any planned improvements are separated out into <xref
        target="pracc_future_work"/> on "Variants and Future Work". As each of
        the above areas is addressed, it will will be removed from this
        section and its decription in the body of the document will be
        updated. Once all areas are complete, this section will be removed.
        Prague CC will then still be a work in progress, but only on a similar
        footing as all other congestion controls.</t>
      </section>

      <section anchor="pracc_motivation"
               title="Motivation: Low Delay /and/ High Bandwidth">
        <t>{ToDo: Copy largely from netdev Prague paper.}</t>

        <t>Not just for today's scale - mention scaling as well as low delay,
        high bandwidth.</t>
      </section>

      <section anchor="pracc_roadmap" title="Document Purpose and Roadmap">
        <t>{ToDo: Explain that there is not 'One True Prague CC'. L4S is
        intended to enable development of any scalable CC that meets the
        Prague requirements. This doc is only meant to describe a reference
        implementation. It doesn't satisfy all the requirements, and the IETF
        might decide that certain requirements need to be relaxed as an
        outcome of the process of trying to satisfy them all.}</t>
      </section>

      <section anchor="pracc_Terminology" title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"/> when, and only when, they appear in all capitals,
        as shown here.</t>

        <t>Definitions of terms used {ToDo: Currently inherited from dualq
        draft - may need to prune}:<list style="hanging">
            <t hangText="Classic Congestion Control:">A congestion control
            behaviour that can co-exist with standard TCP Reno <xref
            target="RFC5681"/> without causing significantly negative impact
            on its flow rate <xref target="RFC5033"/>. With Classic congestion
            controls, as flow rate scales, the number of round trips between
            congestion signals (losses or ECN marks) rises with the flow rate.
            So it takes longer and longer to recover after each congestion
            event. Therefore control of queuing and utilization becomes very
            slack, and the slightest disturbance prevents a high rate from
            being attained <xref target="RFC3649"/>.</t>

            <t hangText="Scalable Congestion Control:">A congestion control
            where the average time from one congestion signal to the next (the
            recovery time) remains invariant as the flow rate scales, all
            other factors being equal. This maintains the same degree of
            control over queueing and utilization whatever the flow rate, as
            well as ensuring that high throughput is robust to disturbances.
            For instance, DCTCP averages 2 congestion signals per round-trip
            whatever the flow rate. For the public Internet a Scalable
            transport has to comply with the requirements in Section 4
            of&nbsp;<xref target="I-D.ietf-tsvwg-ecn-l4s-id"/> (aka. the
            'Prague L4S requirements').</t>

            <t hangText="Reno-friendly:">The subset of Classic traffic that
            excludes unresponsive traffic and excludes experimental congestion
            controls intended to coexist with Reno but without always being
            strictly friendly to it (as allowed by <xref target="RFC5033"/>).
            Reno-friendly is used in place of 'TCP-friendly', given that the
            TCP protocol is used with many different congestion control
            behaviours.</t>

            <t hangText="Classic ECN:">The original Explicit Congestion
            Notification (ECN) protocol <xref target="RFC3168"/>, which
            requires ECN signals to be treated the same as drops, both when
            generated in the network and when responded to by the
            sender.<vspace blankLines="1"/>The names used for the four
            codepoints of the 2-bit IP-ECN field are as defined in <xref
            target="RFC3168"/>: Not ECT, ECT(0), ECT(1) and CE, where ECT
            stands for ECN-Capable Transport and CE stands for Congestion
            Experienced.<vspace blankLines="1"/>A packet marked with the CE
            codepoint is termed 'ECN-marked' or sometimes just 'marked' where
            the context makes ECN obvious.</t>

            <t hangText="CC:">Congestion Control</t>

            <t hangText="ACK:">an ACKnowledgement, or to ACKnowledge</t>

            <t hangText="EWMA:">Exponentially Weighted Moving Average</t>

            <t hangText="RTT:">Round Trip Time</t>
          </list></t>

        <t>Definitions of Parameters and Variables:<list style="hanging">
            <t hangText="MTU_BITS:">Maximum transmission unit [b]</t>

            <t hangText="cwnd:">Congestion window [B]</t>

            <t hangText="ssthresh:">Slow start threshold [B]</t>

            <t hangText="inflight:">The amount of data that the sender has
            sent but not yet received ACKs for [B]</t>

            <t hangText="p:">Steady-state probability of drop or marking
            []</t>

            <t hangText="alpha:">EWMA of the ECN marking fraction []</t>

            <t hangText="acked_sacked:">the amount of new data acknowledged by
            an ACK [B]</t>

            <t hangText="ece_delta:">the amount of newly acknowledged data
            that was ECN-marked [B]</t>

            <t hangText="ai_per_rtt:">additive increase to apply per RTT
            [B]</t>

            <t hangText="srtt:">Smoothed round trip time [s]</t>

            <t hangText="MAX_BURST_DELAY:">Maximum allowed bottleneck queuing
            delay due to segmentation offload bursts [s] (default 0.25 ms for
            the public Internet)</t>
          </list></t>
      </section>
    </section>

    <section anchor="pracc_l4s" title="Bigger Picture - L4S Overview">
      <t/>

      <section title="Low Queuing Delay and High Utilization">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>

      <section title="Immediate Explicit Congestion Notification">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>

      <section title="Scaling with Flow Rate">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>

      <section title="Coexistence with Existing Traffic">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>

      <section title="The Prague L4S Requirements">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>
    </section>

    <section title="DCTCP: Brief Recap">
      <t>{ToDo} Is this needed? Can't we just refer to the DCTCP RFC <xref
      target="RFC8257"/> if interested? We will anyway axplain all aspects? or
      not?</t>
    </section>

    <section anchor="pracc_prague_cc" title="Prague Congestion Control">
      <t/>

      <section anchor="pracc_pkt_id" title="Packet Identification">
        <t>On the public Internet, a sender using the Prague CC MUST set the
        ECT(1) codepoint on all the packets it sends, in order to identify
        itself as an L4S-capable congestion control (Req 4.1 <xref
        target="I-D.ietf-tsvwg-ecn-l4s-id"/>).</t>

        <t>This applies whatever the transport protocol, whether TCP, QUIC,
        RTP, etc. In the case of TCP, unlike an RFC 3168 TCP ECN transport, a
        sender can set all packets as ECN-capable, including TCP control
        packets and retransmissions <xref target="RFC8311"/>, <xref
        target="I-D.ietf-tcpm-generalized-ecn"/>.</t>

        <t>The Prague CC SHOULD optionally be configurable to use the ECT(0)
        codepoint in private networks, such as data centres, which might be
        necessary for backward compatibility with DCTCP deployments where
        ECT(1) might already have another usage.</t>

        <t>Implementation note:<list style="hanging">
            <t hangText="TCP Prague in Linux  kernel:">The kernel was updated
            to allow the ECT(1) flag to be set from within a CC module. The
            Prague CC then has full control over the ECN code point it uses at
            any one time. In this way it enforces the use of ECT(1) (or
            optionally ECT(0)) and non-ECT when required.</t>
          </list></t>
      </section>

      <section title="Detecting and Measuring Congestion">
        <t/>

        <section title="Accurate ECN Feedback">
          <t>When feedback of ECN markings was added to TCP <xref
          target="RFC3168"/>, it was decided not to report any more than one
          mark per RTT. L4S-capable congestion controls need to know the
          extent, not just the existence of congestion (Req 4.2. <xref
          target="I-D.ietf-tsvwg-ecn-l4s-id"/>). Recently defined transports
          (DCCP, QUIC, etc) typically already satisfy this requirement. So
          they are dealt with separately below, while TCP and derivatives such
          as SCTP <xref target="RFC4960"/> are covered first.</t>

          <section title="Accurate ECN Feedback with TCP &amp; Derivatives">
            <t>The TCP wire protocol is being updated to allow more accurate
            feedback (AccECN <xref target="I-D.ietf-tcpm-accurate-ecn"/>).
            Therefore, in the case where a sender uses the Prague CC over TCP,
            whether as client or server:<list style="symbols">
                <t>it MUST itself support AccECN;</t>

                <t>to support AccECN it also has to check that its peer
                supports AccECN during the handshake.</t>
              </list>If the peer does not support accurate ECN feedback, the
            sender MUST fall back to a Reno-friendly CC behaviour for the rest
            of the connection. The non-Prague TCP sender MUST then no longer
            set ECT(1) on the packets it sends. Note that the peer only needs
            to support AccECN; there is no need (and no way) to find out
            whether the peer is using an L4S-capable congestion control.</t>

            <t>Note that a sending TCP client that uses the Prague CC can set
            ECT(1) on the SYN prior to checking whether the other peer
            supports AccECN (as long as it follows the procedure in <xref
            target="I-D.ietf-tcpm-generalized-ecn"/> if it discovers the peer
            does not support AccECN).</t>

            <t>Implementation note:<list style="hanging">
                <t hangText="TCP Prague in Linux  kernel:">The kernel had been
                updated to support AccECN Independent of the CC module in use.
                So the kernel tries to negotiate AccECN exchange whichever
                congestion control module is selected. An additional check is
                provided to verify that the kernel actually does support
                AccECN, based on which the Prague CC module will decide to
                proceed using scalable CC or fall back to a Classic CC (Reno
                in the current implementation).<vspace blankLines="1"/>A
                system wide option is available to disable AccECN negotiation,
                but the Prague CC module will always override this setting, as
                it depends on AccECN. Then, solely in this case, AccECN will
                only be active for TCP flows using the Prague CC.</t>
              </list></t>
          </section>

          <section title="Accurate ECN Feedback with Other Modern Transports">
            <t>Transport protocols specified recently, .e.g. DCCP <xref
            target="RFC4340"/>, QUIC <xref target="I-D.ietf-quic-transport"/>,
            are unambiguously suitable for Prague CCs, because they were
            designed from the start with accurate ECN feedback.</t>

            <t>In the case of RTP/RTCP, ECN feedback was added in <xref
            target="RFC6679"/>, which is sufficient for the Prague CC.
            However, it is preferable to use the most recent improvements to
            ECN feedback in <xref
            target="I-D.ietf-avtcore-cc-feedback-message"/>, as used in the
            implementation of the L4S variant of SCReAM <xref
            target="RFC8298"/>.</t>
          </section>
        </section>

        <section anchor="pracc_moving_avg"
                 title="Moving Average of ECN Feedback">
          <t>The Prague CC currently maintains a moving average of ECN
          feedback in a similar way to DCTCP. This section is provided mainly
          because performance has proved to be sensitive to implementation
          precision in this area. So first, some background is necessary.</t>

          <t>The Prague CC triggers update of its moving average once per RTT
          by recording the packet it sent after the previous update, then
          watching for the ACK of that packet to return. To maintain its
          moving average, it measures the fraction, frac, of ACKed bytes that
          carried ECN feedback over the previous round trip. It then updates
          an exponentially weighted moving average (EWMA) of this fraction,
          called alpha, using the following algorithm:<list style="empty">
              <t>alpha += g * (frac - alpha);</t>
            </list>where g is the gain of the EWMA (default 1/16).</t>

          <t>Implementation notes:<list style="hanging">
              <t hangText="Rounding problems in DCTCP:">Alpha is a fraction
              between 0 and 1, and it needs to be represented with high
              resolution because the larger the bandwidth-delay product (BDP)
              of a flow, the smaller the value that alpha converges to (in
              steady state alpha = 2/cwnd). In principle, Linux DCTCP
              maintains the moving average 'alpha' using the same formula as
              Prague CC uses (as above). Linux represents alpha with a 10-bit
              integer (with resolution 1/1024). However, up to kernel release
              3.19, Linux used integer arithmetic that could not reduce alpha
              below 15/1024. Then it was patched so that any value below
              16/1024 was rounded down to zero <xref
              target="patch-alpha-zero"/>. For a flow with a higher BDP than
              128 segments, this means that, alpha flip-flops. Once it has
              flopped down to zero DCTCP becomes unresponsive until it has
              built sufficient queue to flip up to 16/1024. For larger BDPs,
              this causes DCTCP to induce larger sawteeth, which loses the
              low-queuing-delay and high-utilization intent of the
              algorithm.</t>

              <t hangText="Upscaled alpha in Prague CC:">To resolve the above
              problem the implementation of TCP Prague in Linux maintains
              upscaled_alpha = alpha/g instead of alpha:<list style="empty">
                  <t>upscaled_alpha += frac - g * upscaled_alpha;</t>
                </list>This technique is the same as Linux uses for the
              retransmission timer variables, srtt and mdev. Prague CC also
              uses 20 bits for alpha,</t>
            </list></t>

          <t>Currently the above per-RTT update to the moving average, which
          was inherited from DCTCP, is the default in the Prague CC. However,
          another approach is being investigated because these per-RTT updates
          introduce 1--2 rounds of delay into the congestion response on top
          of the inherent round of feedback delay (see <xref
          target="pracc_faster_response"/> in the section on variants and
          future work).</t>
        </section>

        <section title="Scaling Loss Detection with Flow Rate">
          <t>After an ACK leaves a gap in the sequence space, a Prague CC is
          meant to deem that a loss has occurred using 'time-based units' (Req
          4.3. <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>). This is in
          contrast to the traditional approach that counts a hard-coded number
          of duplicate ACKs, e.g. the 3 Dup-ACKs specified in <xref
          target="RFC5681"/>. Counting packets rather than time unnecessarily
          tightens the time within which parallelized links have to keep
          packets in sequence as flow rate scales over the years.</t>

          <t>To satsify this requirement, a Prague CC SHOULD wait until a
          certain fraction of the RTT has elapsed before it deems that the gap
          is due to packet loss. The reference implementation of TCP Prague in
          Linux uses RACK <xref target="I-D.ietf-tcpm-rack"/> to address this
          requirement. An approach similar to TCP RACK is also used in
          QUIC.</t>

          <t>At the start of a connection, RACK counts 3 DupACKs to detect
          loss because the initial smoothed RTT estimate can be inaccurate.
          This would depend indirectly on time as long as the initial window
          (IW) is paced over a round trip (see <xref
          target="pracc_flow_start"/>). For instance, if the initial window of
          10 segments was paced evenly across the initial RTT then, in the
          next round, an implementation that deems there has been a loss after
          (say) 1/4 of an RTT can count 1/4 of 10 = 3 DupACKs (rounded up).
          Subsequently, as the window grows, RACK shifts to using a fraction
          of the RTT for loss detection.</t>
        </section>
      </section>

      <section anchor="pracc_Congestion_response"
               title="Congestion Response Algorithm">
        <t>In congestion avoidance phase, a Prague CC uses a similar additive
        increase multiplicative decrease (AIMD) algorithm to DCTCP, but with
        the following differences:</t>

        <section anchor="pracc_fallback_loss" title="Fall-Back on Loss">
          <t>A Prague CC has to fall back to Reno-friendly behaviour on
          detection of a loss (Req 4.3. <xref
          target="I-D.ietf-tsvwg-ecn-l4s-id"/>). DCTCP falls back to Reno for
          the round trip after a loss, and the Linux reference implementation
          of TCP Prague inherits this behaviour.</t>

          <t>If a Prague CC has already reduced the congestion window due to
          ECN feedback less than a round trip before it detects a loss, it MAY
          reduce the congestion window by a smaller amount due to the loss, as
          long as the reductions due to ECN and the loss are Reno-friendly
          when taken together.</t>

          <t>See <xref target="pracc_combining_metrics"/> for discussion of
          future work on congestion control using a combination of delay, ECN
          and loss.</t>

          <t>Implementation note:<list style="hanging">
              <t hangText="DCTCP bug prior to v5.1:">A Prague CC cannot rely
              on the fall-back-on-loss behaviour of the DCTCP code in the
              Linux kernel prior to v5.1, due to a previous bug in the fast
              retransmit code (but not in the retransmission timeout code)
              <xref target="patch-loss-react"/>.</t>
            </list></t>
        </section>

        <section anchor="pracc_MD"
                 title="Multiplicative Decrease on ECN Feedback">
          <t>The Prague CC currently responds to ECN feedback in a similar way
          to DCTCP. This section is provided mainly because performance has
          proved to be sensitive to implementation details in this area. So
          the following recap of the congestion response is needed first.</t>

          <t>As explained in <xref target="pracc_moving_avg"/>, the Prague CC
          (like DCTCP) clocks its moving average of ECN-marking, alpha, once
          per round trip throughout a connection. Nonetheless, it only
          triggers a multiplicative decrease to its congestion window when it
          actually receives an ACK carrying ECN feedback. Then it suppresses
          any further decreases for one round trip, even if it receives
          further ECN feedback. This is termed Congestion Window Reduced or
          CWR state.</t>

          <t>The Prague CC (like DCTCP) ensures that the average recovery time
          remains invariant as flow rate scales (Req 4.3 of <xref
          target="I-D.ietf-tsvwg-ecn-l4s-id"/>) by making the multiplicative
          decrease depend on the prevailing value of alpha as follows:<list
              style="empty">
              <t>ssthresh = (1 - alpha/2) * cwnd;</t>
            </list></t>

          <t>Implementation notes:<list style="hanging">
              <t hangText="Upscaled alpha:">With reference to the earlier
              discussion of integer arithmetic precision (<xref
              target="pracc_moving_avg"/>), alpha = g * upscaled_alpha.</t>

              <t hangText="Carry of fractional cwnd remainder:">Typically the
              absolute reduction in the window is only a small number of
              segments. So, if the Prague CC implementation counts the window
              in integer segments (as in the Linux reference code), delay can
              be made significantly less jumpy by tracking a fractional value
              alongside the integer window and carrying over any fractional
              remainder to the next reduction. Also, integer rounding bias
              ought to be removed from the multiplicative decrease
              calculation.</t>
            </list></t>

          <t>In dynamic scenarios, as flows find a new operating point, alpha
          will have often tailed away to near-nothing before the onset of
          congestion. Then DCTCP's tiny reduction followed by no further
          response for a round is precisely the wrong way for a CC to respond.
          A solution to this problem is being evaluated as part of the work
          already mentioned to improve Prague's responsiveness (see <xref
          target="pracc_faster_response"/> in the section on variants and
          future work).</t>
        </section>

        <section anchor="pracc_AI" title="Additive Increase and ECN Feedback">
          <t>Unlike DCTCP, the Prague CC does not suppress additive increase
          for one round trip after a congestion window reduction (while in CWR
          state). Instead, a Prague CC applies additive increase irrespective
          of its CWR state, but only for bytes that have been ACK'd without
          ECN feedback. Specifically, on each ACK,<figure>
              <artwork><![CDATA[    cwnd += (acked_sacked - ece_delta) * ai_per_rtt / cwnd;
]]></artwork>
            </figure>where:<list style="empty">
              <t>acked_sacked is the number of new bytes acknowledged by the
              ACK;</t>

              <t>ece_delta is the number of newly acknowledge ECN-marked
              bytes;</t>

              <t>ai_per_rtt is a scaling factor that is typically 1 SMSS
              except for small RTTs (see <xref
              target="pracc_rtt_independence"/>)</t>
            </list></t>

          <t>Superficially, the traditional suppression of additive increase
          for the round after a decrease seems to make sense. However, DCTCP
          and Prague are designed to induce an average of 2 congestion marks
          per RTT in steady state, which leaves very little space for any
          increase between the end of one round of CWR and the next mark. In
          tests, when a test version of Prague CC is configured to completely
          suppress additive increase during CWR (like Reno and DCTCP), it
          sawteeth become more irregular, which is its way of making some
          decreases large enough to open up enough space for an increase. This
          irregularity tends to reduce link utilization. Therefore, the
          reference Prague CC continues additive increase irrespective of CWR
          state.</t>

          <t>Nonetheless, rather than continue additive increase regardless of
          congestion, it is safer to only increase on those ACKs that do not
          feed back congestion. This approach reduces additive increase as the
          marking probability increases, which tends to keep the marking level
          unsaturated (below 100%) (see Section 3.1 of <xref
          target="Tensions17"/>). Under stable conditions, Prague's congestion
          window then becomes proportional to (1-p)/p, rather than 1/p.</t>

          <t>See also 'Faster than Additive Increase' (<xref
          target="pracc_faster_ai"/>)</t>
        </section>

        <section anchor="pracc_rtt_independence"
                 title="Reduced RTT-Dependence">
          <t>The window-based AIMD described so far was inherited from Reno
          via DCTCP. When many long-running Reno flows share a link, their
          relative packet rates become roughly inversely proportional to RTT
          (packet rate =~ 1/RTT). Then a flow with very small RTT will
          dominate any flows with larger RTTs.</t>

          <t>Queuing delay sets a lower limit to the smallest possible RTT.
          So, prior to the extremely low queuing delay of L4S, extreme cases
          of RTT dependence had never been apparent. Now that L4S has removed
          most of the queuing delay, we have to address the root-cause of
          RTT-dependence, which the Prague CC is required to do, at least when
          the RTT is small (see the 'Reduced RTT bias' aspect of Req 4.3.
          <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>). Here, a small RTT is
          defined as below the typical RTT for the intended deployment
          environment.</t>

          <t>A Prague CC reduces RTT bias by using a reference RTT (RTT_ref)
          rather than the actual round trip (RTT) for all three of: the window
          update period; the EWMA update period; and the duration of CWR state
          after a decrease. As the actual window (cwnd) is still sent within 1
          actual RTT, we also need to use a (conceptual) reference window,
          cwnd_ref. For instance, if RTT_ref = 25 ms then, when the actual RTT
          is 5 ms, there are RTT_ref/RTT = 5 times more packets in cwnd_ref,
          than in the actual window, cwnd, because it spans 5 actual round
          trips. We define M as the ratio RTT_ref/RTT.<!--ToDo: Say what the reference values are not used for:
* cwnd_ref is not used for regulating the sending of packets (i.e. Prague still uses the min  of cwnd and rwnd)

RTT_ref is /not/ used for:
* retransmission timers (i.e. RTT is still used)--></t>

          <t>In the Linux implementation of TCP Prague, RTT_ref is a function
          of the actual RTT. 3 functions have been implemented: RTT_ref =
          max(RTT, RTT_REF_MIN); RTT_ref = RTT + AdditionalRTT; RTT_ref = ...
          {ToDo}. The current default is RTT_ref = max(RTT, 25ms), which
          addresses the main Prague requirement for when the RTT is smaller
          than typical.</t>

          <t>In Reno or DCTCP, additive increase is implemented by dividing
          the desired increase of 1 segment per round over the cwnd packets in
          the round. This requires an increase of 1/cwnd per packet. In the
          Linux implementation of TCP Prague, the aim is to increase the
          reference window by 1 segment over a reference round. However, in
          practice the increase is applied to the actual window, cwnd, which
          is M times smaller than cwnd_ref. So cwnd has to be increased by
          only 1/M segments over RTT_ref. But again, in practice, the increase
          is applied over an actual window of packets spanning an actual RTT,
          which is also M times smaller than the reference RTT. So the desired
          increase in cwnd is only 1/M^2 segments over an actual round trip
          containing cwnd packets. Therefore, the increase in cwnd per packet
          has to be (1/M^2) * (1/cwnd).</t>

          <t>Unless a flow lasts long enough for rates to converge, equal
          rates will not be relevant. So, the Reduced RTT-Dependence algorithm
          only comes into effect after D rounds, where D is configurable
          (current default 500). Continuing the previous example, if actual
          RTT=5 ms and RTT_ref = 25 ms, then Prague would stop using its
          RTT-dependent algorithm after 500*5ms = 2.5s and instead it would
          start to converge to equal rates using the Reduced RTT-Dependence
          algorithm. If the actual RTT were higher (e.g. 20ms), it would stay
          in RTT-dependent mode for longer (10s), but this would be mitigated
          by its RTT being closer to the reference (20ms vs. 25ms).</t>

          <t>This approach prevents reduced RTT-dependence from making the
          flow less responsive at start-up and ensures that its early
          throughput share is based on its actual RTT. The benefit is that
          short flows (mice) give themselves priority over longer flows
          (elephants), and shorter RTTs will still converge faster than longer
          RTTs. Nonetheless, the throughput still converges to equal rates
          after D rounds.</t>

          <t>It is planned to reset the algorithm to be RTT-dependent after an
          idle, not just at flow start, as discussed under Future Work in
          <xref target="pracc_further_rtt_independence"/>.</t>

          <t><xref target="pracc_further_rtt_independence"/> also discusses
          extending the reduction in RTT-dependence to longer RTTs than than
          RTT_ref. The current Prague implementation does not support
          this.</t>
        </section>

        <section anchor="pracc_flow_start" title="Flow Start or Restart">
          <t>Currently the Linux reference implementation of TCP Prague uses
          the standard Linux slow start code. Slow start is exited once a
          single mark is detected.</t>

          <t>When other flows are actively filling the link, regular marks are
          expected, causing slow start of new flows to end prematurely. This
          is clearly not ideal, so other approaches are being worked on (see
          <xref target="pracc_flow_start_future"/>). However, slow start has
          been left as the default until a properly matured solution is
          completed.</t>
        </section>
      </section>

      <section title="Packet Sending">
        <t/>

        <section title="Packet Pacing">
          <t>The Prague CC SHOULD pace the packets it sends to avoid the
          queuing delay and under-utilization that would otherwise be caused
          by bursts of packets that can occur, for example, when a jump in the
          acknowledgement number opens up cwnd. Prague does this in a similar
          way to the base Linux TCP stack, by spacing out the window of
          packets evenly over the round trip time, using the following
          calculation of the pacing rate [b/s]:<list style="empty">
              <t>pacing_rate = MTU_BITS * max(cwnd, inflight) / srtt;</t>
            </list></t>

          <t>During slow start, as in the base Linux TCP stack, Prague factors
          up pacing_rate by 2, so that it paces out packets twice as fast as
          they are acknowledged. This keeps up with the doubling of cwnd, but
          still prevents bursts in response to any larger transient jumps in
          cwnd.<figure>
              <artwork><![CDATA[    if (cwnd < ssthresh / 2)
        pacing_rate *= 2;
]]></artwork>
            </figure></t>

          <t>During congestion avoidance, the Linux TCP Prague implementation
          does not factor up pacing_rate at all. This contrasts with the base
          Linux TCP stack, which currently factors up pacing_rate by a ratio
          parameter set to 1.2. The developers of the base Linux stack
          confirmed that this factor of 1.2 was only introduced in case it
          improved performance, but there were no scenarios where it was known
          to be needed. In testing of Prague, this factor was found to cause
          queue delay spikes whenever cwnd jumped more than usual. And
          throughput was no worse without it. So it was removed from the TCP
          Prague CC.</t>

          <t>The Prague CC can use alternatives to the traditional slow-start
          algorithm, which use different pacing (see <xref
          target="pracc_flow_start"/>).</t>
        </section>

        <section title="Segmentation Offload">
          <t>In the absence of hardware pacing, it becomes increasingly
          difficult for a machine to scale to higher flow rates unless it is
          allowed to send packets in larger bursts, for instance using
          segmentation offload. Happily, as flow rate scales up,
          proportionately more packets can be allowed in a burst for the same
          amount of queuing delay at the bottleneck.</t>

          <t>Therefore, the Prague CC sends packets in a burst as long as it
          will not induce more than MAX_BURST_DELAY of queuing at the
          bottleneck. From this constant and the current pacing_rate, it
          calculates how many MTU-sized packets to allow in a burst:<list
              style="empty">
              <t>max_burst = pacing_rate * MAX_BURST_DELAY / MTU_BITS</t>
            </list>The current default in the Linux TCP Prague for
          MAX_BURST_DELAY is 250us which supports marking thresholds starting
          from about 500us without underutilization. This approach is similar
          to that in the Linux TCP stack, except there MAX_BURST_DELAY is
          1ms.</t>
        </section>
      </section>
    </section>

    <!--ToDo: RFC5033 lists subjects that the spec of an alternative CC should cover.-->

    <section anchor="pracc_future_work" title="Variants and Future Work">
      <t/>

      <section title="Getting up to Speed Faster">
        <t>Appendix A.2. of <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>
        outlines the performance optimizations needed when transplanting DCTCP
        from a DC environment to a wide area network. The following
        subsections address two of those points: faster flow startup and
        faster than additive increase. Then <xref
        target="pracc_faster_response"/> covers the flip side, in which
        established flows have to yield faster to make room, otherwise queuing
        will result.</t>

        <section anchor="pracc_flow_start_future"
                 title="Flow Start (or Restart)">
          <t>The Prague performance For faster flow start, two approaches are
          currently being investigated in parallel:<list style="hanging">
              <t hangText="Modified Slow Start:">The traditional exponential
              slow start can be modified both at the start and the end, with
              the aim of reducing the risk of queuing due to bursts and
              overshoot:<list style="hanging">
                  <t hangText="Pacing IW:">A Prague CC can use an initial
                  window of 10 (IW10 <xref target="RFC6928"/>), but pacing of
                  this Initial Window is recommended to try to avoid the pulse
                  of queuing that could otherwise occur. Pacing IW10 also
                  spreads the ACKs over the round trip so that subsequent
                  rounds consist of ten subsets of packets (with 2, 4, 8 etc.
                  per round in each subset), rather than a single set with 20,
                  40, 80 etc. in each round. Then, if a queue builds during a
                  round (e.g. due to other unexpected traffic arriving) it can
                  drain in the gap before the next subset, rather than the
                  whole set backing up in a much larger queue.<vspace
                  blankLines="1"/>In the Linux reference implementation of TCP
                  Prague, IW pacing can be optionally enabled, but it is off
                  by default, because it is yet to be fully evaluated. It
                  currently paces IW over half the initial smoothed round trip
                  time (SRTT) measured during the handshake. SRTT is halved
                  because the RTT often reduces after the initial handshake.
                  For example: i) some CDNs move the flow to a closer server
                  after establishment; ii) the initial RTT from a server can
                  include the time to wake a sleeping handset battery; iii)
                  some uplink technologies take a link-level round trip to
                  request a scheduling slot.<vspace blankLines="1"/>It is
                  planned to exploit any cached knowledge of the path RTT to
                  improve the initial estimate, for instance using the Linux
                  per-destination cache. it is also planned to allow the
                  application to give an RTT hint (by setting
                  sk_max_pacing_rate in Linux) if the developer has reason to
                  believe that the application has a better estimate.</t>

                  <t hangText="Exiting slow start more gracefully:">In the
                  wide area Internet (in contrast to data centres), bottleneck
                  access links tend to have much less capacity than the line
                  rate of the sender. With a shallow immediate ECN threshold
                  at this bottleneck, the slightest burst can tend to induce
                  an ECN mark, which traditionally causes slow start to exit.
                  A more gradual exit is being investigated for a Prague CC
                  using the extent of marking, not just the existence of a
                  single mark. This will be more consistent with the
                  extent-based marking that scalable congestion controls use
                  during congestion avoidance. Delay measurements (similar to
                  Hystart++ <xref target="I-D.ietf-tcpm-hystartplusplus"/>)
                  can also be used to complement the ECN signals.</t>
                </list></t>

              <t hangText="Paced Chirping:">In this approach, the aim is to
              both increase more rapidly than exponential slow-start and to
              greatly reduce any overshoot. It is primarily a delay-based
              approach, but the aim is also to exploit ECN signals when
              present (while not forgetting loss either). Therefore Paced
              Chirping is generally usable for any congestion control - not
              solely for Prague CC and L4S.<vspace blankLines="1"/>Instead of
              only aiming to detect capacity overshoot at the end of
              flow-start, brief trains of rapidly decreasing inter-packet
              spacing called chirps are used to test many rates with as few
              packets and as little load as possible. A full description is
              beyond the scope of this document. <xref
              target="LinuxPacedChirping"/> introduces the concepts and the
              code as well as citing the main papers on Paced Chirping.<vspace
              blankLines="1"/>Paced chirping works well over continuous links
              such as Ethernet and DSL. But better averaging and noise
              filtering are necessary over discontinuous link technologies
              such as WiFi, LTE cellular radio, passive optical networks (PON)
              and data over cable (DOCSIS). This is the current focus of this
              work.<vspace blankLines="1"/>The current Linux implementation of
              TCP Prague does not include Paced Chirping, but research code is
              available separately in Linux and ns3. it is accessible via the
              L4S landing page <xref target="L4S-home"/>.</t>
            </list></t>
        </section>

        <section anchor="pracc_faster_ai"
                 title="Faster than Additive Increase">
          <t>The Prague CC has a startup phase and congestion avoidance phase
          like traditional CCs. In steady-state during congestion avoidance,
          like all scalable congestion controls, it induces frequent ECN
          marks, with the same average recovery time between ECN marks, no
          matter how much the flow rate scales. </t>

          <t>If available capacity suddenly increases, e.g. other flow(s)
          depart or the link capacity increases, these regular ECN marks will
          stop. Therefore after a few rounds of silence (no ECN marks) in
          congestion avoidance phase, the Prague CC can assume that available
          capacity has increased, and switch to using the techniques from its
          startup phase (<xref target="pracc_flow_start_future"/>) to rapidly
          find the new, faster operating point. Then it can shift back into
          its congestion avoidance behaviour.</t>

          <t>That is the theory. But, as explained in <xref
          target="pracc_flow_start_future"/>, the startup techniques,
          specifically paced chirping, are still being developed for
          discontinuous link types. Once the startup behaviour is available,
          the Linux implementation of the Prague CC will also have a faster
          than additive increase behaviour. S.3.2.3 of <xref
          target="PragueLinux"/>) gives a brief preview of the performance of
          this approach over an Ethernet link type in ns3.</t>
        </section>

        <section anchor="pracc_faster_response"
                 title="Remove Lag in Congestion Response">
          <t>To keep queuing delay low, new flows can only push in fast if
          established flows yield fast. It has recently been realized that the
          design of the Prague EWMA and congestion response introduces 1-2
          rounds of lag (on top of the inherent round of feedback delay due to
          the speed of light). These lags were inherited from the design of
          DCTCP (see <xref target="pracc_moving_avg"/> and <xref
          target="pracc_MD"/>), where a couple of extra hundred microseconds
          was less noticeable. But congestion control in the wide area
          Internet cannot afford up to 2 rounds trips of extra lag.</t>

          <t>To be clear, lag means delay before any response at all starts.
          That is qualititatively different from the smoothing gain of an
          EWMA, which /reduces/ the response by the gain factor (1/16 by
          default) in case a change in congestion does not persist. Smoothing
          gain can always be increased. But 1-2 rounds of lag means that, when
          a new flow tries to push in, the sender of an established flow will
          not respond /at all/ for 1-2 rounds after it first receives
          congestion feedback.</t>

          <t>The Prague CC spends the first round trip of this lag gathering
          feedback to measure frac before it is input into the EWMA algorithm
          (see <xref target="pracc_moving_avg"/>). Then there is up to one
          further round of delay because the implementations of DCTCP and
          Prague did not fully adopt the paradigm shift to extent-based
          marking - the timing of the decrease is still based on Reno. </t>

          <t>Both Reno and DCTCP/Prague respond immediately on the first sign
          of congestion. Reno's response is large, so it waits a round in CWR
          state to allow the response to take effect. DCTCP's response is tiny
          (extent-based), but then it still waits a round in CWR state. So it
          does next-to-nothing for a round.</t>

          <t>New EWMA and resposne algorithms to remove these 1-2 extra rounds
          of lag are described in <xref target="PerAckEWMA"/>. They have been
          implemented in Linux and an iterative process of evaluation and
          redesign is in progress. The EWMA is updated per-ACK, but it still
          changes as if it is clocked per round trip. The congestion response
          is still triggered by the first indication of ECN feedback, but it
          proceeds over the subsequent round trip so that it can take into
          account further incoming feedback as the EWMA evolves. The reduction
          is applied per-ACK but sized to result as if it had been a single
          response per round trip, </t>
        </section>
      </section>

      <section anchor="pracc_combining_metrics"
               title="Combining Congestion Metrics">
        <t>Ultimately, it would be preferable to take an integrated approach
        and use a combination of ECN, loss and delay metrics to drive
        congestion control. For instance, using a downward trend in ECN
        marking and/or delay as a heuristic to temper the response to loss.
        Such ideas are not in the immediate plans for the Linux TCP Prague,
        but some more specific ideas are highlighted in the following
        subsections.</t>

        <section title="ECN with Loss">
          <t>If the bottleneck is ECN-capable, a loss due to congestion is
          very likely to have been preceded by a period of ECN marking. When
          the current Linux TCP Prague CC detects a loss, like DCTCP, it
          halves cwnd, even if it has already reduced cwnd in the same round
          trip due to ECN marking. This double reduction can end up factoring
          down cwnd to as little as 1/4 in one round trip.</t>

          <t>On a loss while in CWR state following an ECN reduction, it would
          be possible to factor down cwnd by 1/(2-alpha), which would compound
          with the previous decrease factor of (1-alpha/2) to result in: (1 -
          alpha/2) / (2-alpha)) = 1/2. In integer arithmetic, this division
          would be possible but relatively expensive. A less expensive
          alternative would be multiplication by (2+alpha)/4, which
          approximates to a compounded decrease factor of 1/2 for typical low
          values of alpha, even up to 30%. The compound decrease factor is
          never greater than 1/2 and in the worst case, if alpha was 100%, it
          would factor cwnd down by 3/8.</t>
        </section>

        <section title="ECN with Delay">
          <t><xref target="pracc_faster_ai"/> described the plans to shift
          between using ECN when close to the operating point and using delay
          by injecting paced chirps to find a new operating after the ECN
          signal goes silent for a few rounds. Paced chirping shifts more
          slowly to the new operating point the more noise there is in the
          delay measurements. Work is ongoing on treating any ECN marking as a
          complementary metric. The resulting less noisy combined metric
          should then allow the controller to shift more rapidly to each new
          operating point.</t>

          <t>An alternative would be to combine ECN with the BBR approach,
          which induces a much less noisy delay signal by using less frequent
          but more pronounced delay spikes. The approach currently being taken
          is to adapt the chirp length to the degree of noise, so the chirps
          only become longer and/or more pronounced when necessary, for
          instance when faced with a discontinuous link technology such as
          WiFi. With multiple chirps per round, the noise can still be
          filtered out by averaging over them all, rather than trying to
          remove noise from each spike. This keeps the 'self-harm' to the
          minimum necessary, and ensures that capacity is always being
          sampled, which removes the risk of going stale.</t>
        </section>
      </section>

      <section title="Fall-Back on Classic ECN">
        <t>The implementation of TCP Prague CC in Linux includes an algorithm
        to detect a Classic ECN AQM and fall back to Reno as a result, as
        required by the 'Coexistence with Classic ECN' aspect of the Prague
        Req 4.3. <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>. </t>

        <t>The algorithm currently used (v2) is relatively simple, but rather
        than describe it here, full rationale, pseudocode and explanation can
        be found in the technical report about it <xref
        target="ecn-fallback"/>. This also includes a selection of the
        evaluation results and a link to visualizations of the full results
        online. The current algorithm nearly always detects a Classic ECN AQM,
        and in the majority of the wide range of scenarios tested it is good
        at detecting an L4S AQM. However, it wrongly identifies and L4S AQM as
        Classic in a significant minority of cases when the link rate is low,
        or the RTT is high. The report gives ideas on how to improve detection
        in these scenarios, but in the mean time the algorithm has been
        disabled by default.</t>

        <t>Recently, the report has been updated to include new ideas on other
        ways to distinguish Classic from L4S AQMs. The interested reader can
        access it themselves, so this living document will not be further
        summarized here.</t>
      </section>

      <section anchor="pracc_further_rtt_independence"
               title="Further Reduced RTT-Dependence">
        <t>The algorithm to reduce RTT dependence is only relevant for
        long-running flows. So in the current TCP Prague implementation it
        remains disabled for a certain number of round trips after the start
        of a flow, as explained in <xref target="pracc_rtt_independence"/>. It
        would be possible to make RTT_ref gradually move from the actual RTT
        to the target reference RTT, or peerhaps depend on other parameters of
        the flow. Nonetheless, just switching in the algorithm after a number
        of rounds works well enough. It is planned to also disable the
        algorithm for a similar duration if a flow becomes idle then restarts,
        but this is yet to be evaluated.</t>

        <t>Prague Req 4.3. in <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>) only
        requires reduced RTT bias "in the range between the minimum likely RTT
        and typical RTTs expected in the intended deployment scenario". For
        RTTs higher than typical, the RTT bias of the Prague CC is no worse
        than that of Classic CCs, as long as the bottleneck has heeded the
        recommendations to avoid using an on-off AQM.</t>

        <t>If a step AQM is used, the congestion episodes of flows with
        different RTTs tend to synchronize. If two scalable CCs are allowed to
        synchronize, the analysis in section IV of <xref target="BIC"/>
        explains that RTT unfairness will approach infinity. </t>

        <t>To prevent this, either step AQMs would have to be deprecated for
        L4S (they are not the preferred recommendation in <xref
        target="I-D.ietf-tsvwg-aqm-dualq-coupled"/>), or the reference RTT
        approach of <xref target="pracc_rtt_independence"/> could be used for
        higher than typical RTTs as well as lower. In this latter case,
        (RTT/RTT_ref)^2 segments would need to be added to the window per
        reference RTT. The current TCP Prague implementation does not support
        this faster AI for RTTs higher than RTT_ref, due to the expected (but
        unverified) impact on latency overshoot and responsiveness.</t>
      </section>

      <section anchor="pracc_fractional_windows"
               title="Scaling Down to Fractional Windows">
        <t>A modification to v5.0 of the Linux TCP stack that scales down to
        sub-packet windows is available for research purposes via the L4S
        landing page <xref target="L4S-home"/>. The L4S Prague Requirements in
        section 4.3 of <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/> recommend
        but no longer mandate scaling down to sub-packet windows. This is
        because becoming unresponsive at a minimum window is a tradeoff
        between protecting against other unresponsive flows and the extra
        queue you induce by becoming unresponsive yourself. So this code is
        not maintained as part of the Linux implementation of TCP Prague.</t>

        <t>Firstly, the stack ahs to be modifed to maintain a fractional
        congestion window. The because the ACK clock cannot work below 1
        packet per RTT, the code sets the time to send each packet, then
        readjusts the timing as each ACK arrives (otherwise any queuing
        accumulates a burst in subsequent rounds). Also, additive increase of
        one segment does not scale below a 1-segment window. So instead of a
        constant additive increase, the code uses a logarithmically scaled
        additive increase that slowly adapts the additive increase constant to
        the slow start threshold. Despite these quite radical changes, the
        diff is surprisingly small. The design and implementation is explained
        in <xref target="Ahmed19"/>, which also includes evaluation
        results.</t>
      </section>
    </section>

    <section anchor="pracc_IANA" title="IANA Considerations">
      <t>This specification contains no IANA considerations.</t>
    </section>

    <section anchor="pracc_Security_Considerations"
             title="Security Considerations">
      <t><xref target="pracc_fractional_windows"/> on scaling down to
      fractional windows discusses the tradeoff in becoming unresponsive at a
      minium window, which causes a queue to build (harm to self and to
      others) but protects oneself against other unresponsive flows (whether
      malicious or accidental).</t>

      <t>This draft inherits the security considerations discussed in <xref
      target="I-D.ietf-tsvwg-ecn-l4s-id"/> and in the L4S architecture <xref
      target="I-D.ietf-tsvwg-l4s-arch"/>. In particular, the self-interest
      incentive to be responsive and minimize queuing delay, and protections
      against those interested in disrupting the low queuing delay of
      others.</t>
    </section>

    <section title="Acknowledgements">
      <t>Bob Briscoe's contribution was part-funded by the Comcast Innovation
      Fund. The views expressed here are solely those of the authors.</t>
    </section>

    <section title="Contributors">
      <t>The following contributed implementations and evaluations that
      validated and helped to improve this specification:<list style="empty">
          <t>Olivier Tilmans &lt;olivier.tilmans@nokia-bell-labs.com&gt; of
          Nokia Bell Labs, Belgium, prepared and maintains the Linux
          implementation of TCP Prague.</t>

          <t>Koen De Schepper &lt;koen.de_schepper@nokia-bell-labs.com&gt; of
          Nokia Bell Labs, Belgium, contributed to the Linux implementation of
          TCP Prague.</t>

          <t>Joakim Misund &lt;joakim.misund@gmail.com&gt; of Uni Oslo,
          Norway, wrote the Linux paced chirping code.</t>

          <t>Asad Sajjad Ahmed &lt;me@asadsa.com&gt;, Independent, Norway,
          wrote the Linux code that maintains a sub-packet window.</t>
        </list></t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>

      <?rfc include='reference.RFC.3168'?>

      <?rfc include='reference.RFC.8311'?>

      <?rfc include='reference.I-D.ietf-tsvwg-ecn-l4s-id'?>

      <?rfc include='reference.I-D.ietf-tcpm-accurate-ecn'?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.RFC.3649'?>

      <?rfc include='reference.RFC.4340'?>

      <?rfc include='reference.RFC.4960'?>

      <?rfc include='reference.RFC.5033'?>

      <?rfc include='reference.RFC.5681'?>

      <?rfc include='reference.RFC.6679'?>

      <?rfc include='reference.RFC.6928'?>

      <?rfc include='reference.RFC.8257'?>

      <?rfc include='reference.RFC.8298'?>

      <?rfc include='reference.I-D.ietf-tsvwg-l4s-arch'?>

      <?rfc include='reference.I-D.ietf-tsvwg-aqm-dualq-coupled'?>

      <?rfc include='reference.I-D.ietf-avtcore-cc-feedback-message'?>

      <?rfc include='reference.I-D.ietf-tcpm-rack'?>

      <?rfc include='reference.I-D.ietf-tcpm-generalized-ecn'?>

      <?rfc include='reference.I-D.ietf-quic-transport'?>

      <?rfc include='reference.I-D.ietf-tcpm-hystartplusplus'?>

      <reference anchor="PragueLinux"
                 target="https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s">
        <front>
          <title>Implementing the `TCP Prague' Requirements for Low Latency
          Low Loss Scalable Throughput (L4S)</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <author fullname="Koen De Schepper" initials="K."
                  surname="De Schepper">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Olga Albisser" initials="O." surname="Albisser">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Joakim Misund" initials="J." surname="Misund">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Mirja K&uuml;hlewind" initials="M."
                  surname="K&uuml;hlewind">
            <organization>ETH Zurich</organization>
          </author>

          <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
            <organization>Simula Research Lab</organization>
          </author>

          <date month="March" year="2019"/>
        </front>

        <seriesInfo name="Proc. Linux Netdev 0x13" value=""/>

        <format target="https://www.files.netdevconf.org/f/4d6939d5f1fb404fafd1/?dl=1"
                type="PDF"/>
      </reference>

      <reference anchor="PerAckEWMA" target="https://arxiv.org/abs/2101.07727">
        <front>
          <title>Improving DCTCP/Prague Congestion Control
          Responsiveness</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <date day="20" month="January" year="2021"/>
        </front>

        <seriesInfo name="Technical Report" value="TR-BB-2020-002"/>

        <format target="https://arxiv.org/pdf/2101.07727" type="PDF"/>
      </reference>

      <reference anchor="patch-alpha-zero"
                 target="https://github.com/torvalds/linux/commits/master/net/ipv4/tcp_dctcp.c">
        <front>
          <title>tcp: allow dctcp alpha to drop to zero</title>

          <author fullname="Andrew G. Shewmaker" initials="A. G. "
                  surname="Shewmaker">
            <organization/>
          </author>

          <date day="23" month="October" year="2015"/>
        </front>

        <seriesInfo name="Linux GitHub patch;" value="Commit: c80dbe0"/>

        <format target="https://github.com/torvalds/linux/commit/c80dbe04612986fd6104b4a1be21681b113b5ac9"
                type="HTML"/>
      </reference>

      <reference anchor="patch-loss-react"
                 target="https://github.com/torvalds/linux/commits/master/net/ipv4/tcp_dctcp.c">
        <front>
          <title>tcp: Ensure DCTCP reacts to losses</title>

          <author fullname="Koen De Schepper" initials="K. "
                  surname="De Schepper">
            <organization/>
          </author>

          <date day="4" month="April" year="2019"/>
        </front>

        <seriesInfo name="Linux GitHub patch;" value="Commit: aecfde2"/>

        <format target="https://github.com/torvalds/linux/commit/aecfde23108b8e637d9f5c5e523b24fb97035dc3"
                type="HTML"/>
      </reference>

      <reference anchor="Tensions17" target="https://arxiv.org/abs/1904.07605">
        <front>
          <title>Resolving Tensions between Congestion Control Scaling
          Requirements</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization/>
          </author>

          <author fullname="Koen De Schepper" initials="K. "
                  surname="De Schepper">
            <organization/>
          </author>

          <date month="July" year="2017"/>
        </front>

        <seriesInfo name="Simula Technical Report"
                    value="TR-CS-2016-001; arXiv:1904.07605"/>

        <format target="https://arxiv.org/pdf/1904.07605" type="PDF"/>
      </reference>

      <reference anchor="L4S-home" target="https://riteproject.eu/dctth/#code">
        <front>
          <title>L4S: Ultra-Low Queuing Delay for All</title>

          <author>
            <organization/>
          </author>

          <date day="" month="" year=""/>
        </front>

        <format target="https://riteproject.eu/dctth/" type="HTML"/>
      </reference>

      <reference anchor="LinuxPacedChirping"
                 target="https://www.netdevconf.org/0x13/session.html?talk-chirp">
        <front>
          <title>Paced Chirping - Rethinking TCP start-up</title>

          <author fullname="Joakim Misund" initials="J." surname="Misund">
            <organization>University of Oslo</organization>
          </author>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <date month="March" year="2019"/>
        </front>

        <seriesInfo name="Proc. Linux Netdev 0x13" value=""/>

        <format target="https://www.files.netdevconf.info/f/da8cc04a608a448f890e/?dl=1"
                type="PDF"/>
      </reference>

      <reference anchor="ecn-fallback"
                 target="https://arxiv.org/abs/1911.00710">
        <front>
          <title>TCP Prague Fall-back on Detection of a Classic ECN
          AQM</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
            <organization>Simula and Uni Oslo</organization>
          </author>

          <date month="April" year="2020"/>
        </front>

        <seriesInfo name="bobbriscoe.net Technical Report"
                    value="TR-BB-2019-002"/>

        <format target="https://arxiv.org/abs/1911.00710" type="PDF"/>
      </reference>

      <reference anchor="BIC" target="DOI: 10.1109/INFCOM.2004.1354672">
        <front>
          <title>Binary Increase Congestion Control for Fast Long-Distance
          Networks</title>

          <author fullname="Lisong Xu" initials="L." surname="Xu">
            <organization/>
          </author>

          <author fullname="Khaled Harfoush" initials="K." surname="Harfoush">
            <organization/>

            <address>
              <postal>
                <street/>

                <city/>

                <region/>

                <code/>

                <country/>
              </postal>

              <phone/>

              <facsimile/>

              <email/>

              <uri/>
            </address>
          </author>

          <author fullname="Injong Rhee" initials="I." surname="Rhee">
            <organization/>

            <address>
              <postal>
                <street/>

                <city/>

                <region/>

                <code/>

                <country/>
              </postal>

              <phone/>

              <facsimile/>

              <email/>

              <uri/>
            </address>
          </author>

          <date month="March" year="2004"/>
        </front>

        <seriesInfo name="Proc. IEEE Infocom'04" value="4(2514--2524)"/>

        <format target="https://ieeexplore.ieee.org/document/1354672"
                type="PDF"/>
      </reference>

      <reference anchor="Ahmed19"
                 target="https://www.duo.uio.no/handle/10852/70966">
        <front>
          <title>Extending TCP for Low Round Trip Delay</title>

          <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
            <organization>Simula and Uni Oslo</organization>
          </author>

          <date month="August" year="2019"/>
        </front>

        <seriesInfo name="Masters Thesis, Uni Oslo" value=""/>

        <format target="https://www.duo.uio.no/bitstream/handle/10852/70966/main.pdf?sequence=5&amp;isAllowed=y"
                type="PDF"/>
      </reference>
    </references>

    <section title="{ToDo}">
      <t>Delete if not needed.</t>
    </section>

    <!--    <section title="Open Issues">
      <t>Minor open issues are tagged '{ToDo}' at the appropriate point in the
      document. Major open issues are listed below:<list>
          <t>None</t>
        </list></t>
    </section>

    <section title="Change Log (to be Deleted before Publication)">
      <t>A detailed version history can be accessed at
      &lt;http://datatracker.ietf.org/doc/draft-briscoe-aqm-ecn-roadmap/history/&gt;</t>

      <t><list style="hanging">
          <t hangText="From briscoe-...-00 to briscoe-...-01:">Technical
          changes:<list style="symbols">
              <t/>
            </list>Editorial changes:<list style="symbols">
              <t/>
            </list></t>
        </list></t>
    </section>
-->
  </back>
</rfc>

<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="exp" docName="draft-briscoe-iccrg-prague-congestion-control-00"
     ipr="trust200902" updates="">
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
       full title is longer than 39 characters -->

    <title abbrev="Prague Congestion Control">Prague Congestion
    Control</title>

    <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
      <organization>Nokia Bell Labs</organization>

      <address>
        <postal>
          <street/>

          <city>Antwerp</city>

          <country>Belgium</country>
        </postal>

        <email>koen.de_schepper@nokia.com</email>

        <uri>https://www.bell-labs.com/usr/koen.de_schepper</uri>
      </address>
    </author>

    <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
      <organization>Nokia Bell Labs</organization>

      <address>
        <postal>
          <street/>

          <city>Antwerp</city>

          <country>Belgium</country>
        </postal>

        <email>olivier.tilmans@nokia-bell-labs.com</email>
      </address>
    </author>

    <author fullname="Bob Briscoe" initials="B." role="editor"
            surname="Briscoe">
      <organization>Independent</organization>

      <address>
        <postal>
          <street/>

          <country>UK</country>
        </postal>

        <email>ietf@bobbriscoe.net</email>

        <uri>http://bobbriscoe.net/</uri>
      </address>
    </author>

    <date month="" year=""/>

    <area>IRTF</area>

    <workgroup>Internet Congestion Control Research Group (ICCRG)</workgroup>

    <keyword>Internet-Draft</keyword>

    <keyword>I-D</keyword>

    <abstract>
      <t>This specification defines the Prague congestion control scheme,
      which is derived from DCTCP and adapted for Internet traffic by
      implementing the Prague L4S requirements. Over paths with L4S support at
      the bottleneck, it adapts the DCTCP mechanisms to achieve consistently
      low latency and full throughput. It is defined independently of any
      particular transport protocol or operating system, but notes are added
      that highlight issues specific to certain transports and OSs. It is
      mainly based on the current default options of the reference Linux
      implementation of TCP Prague, but it includes experience from other
      implementations where available. It separately describes non-default and
      optional parts, as well as future plans.</t>

      <t>The implementation does not satisfy all the Prague requirements (yet)
      and the IETF might decide that certain requirements need to be relaxed
      as an outcome of the process of trying to satisfy them all. In two
      cases, research code is replaced by placeholders until full evaluation
      is complete.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="pracc_intro" title="Introduction">
      <t>This document defines the Prague congestion control. It is defined
      independent of any particular transport protocol or operating system,
      but notes are added that highlight issues specific to certain transports
      and OSs. The authors are most familiar with the reference implementation
      of Prague on Linux over TCP. So that forms the basis of the large
      majority of platform-specific notes. Nonetheless, wherever possible,
      experience from implementers on other platforms is included, and the
      intention is to gather more into this document during the drafting
      process.</t>

      <t>The Prague CC is intended to maintain consistently low queuing delay
      over network paths that offer L4S support at the bottleneck. Where the
      bottleneck does not support L4S, the Prague CC is intended to fall back
      to behaving like a conventional 'Classic' congestion control. L4S stands
      for Low Latency, Low Loss Scalable throughput. L4S support in the
      network involves Active Queue Management (AQM) with a very shallow
      target queueing delay (of the order of a millisecond) that applies
      immediate Explicit Congestion Notification (ECN). 'Immediate ECN' means
      that the network applies ECN marking based on the instantaneous queue,
      without any smoothing or filtering, The Prague CC takes on the job of
      smoothing and filtering the congestion signals from the network.</t>

      <t>The Prague CC is a particular instance of a scalable congestion
      control, which is defined in <xref target="pracc_Terminology"/>.
      Scalable congestion control is the part of the L4S architecture that
      does the actual work of maintaining low queuing delay and ensuring that
      the delay and throughput properties scale with flow rate.</t>

      <t>The L4S architecture <xref target="I-D.ietf-tsvwg-l4s-arch"/> places
      the host congestion control in the context of the other parts of the
      system. In particular the different types of L4S AQM in the network and
      the codepoints in the IP-ECN field that convey to the network that the
      host supports the L4S form of ECN. The architecture document also covers
      other issues such as: incremental deployment; protection of low latency
      queues against accidental or malicious disruption; and the relationship
      of L4S to other low latency technologies. The specification of the L4S
      ECN Protocol <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/> sets down the
      requirements that the Prague CC has to follow (called the Prague L4S
      Requirements - see <xref target="pracc_Prague_L4S_reqs"/> for a
      summary).</t>

      <t>Links to implementations of the Prague CC and other scalable
      congestion controls (all open source) can be found via the L4S landing
      page <xref target="L4S-home"/>, which also links to numerous other
      L4S-related resources. A (slightly dated) paper on the specific
      implementation of the Prague CC in Linux over TCP is also available
      <xref target="PragueLinux"/>, and the code is at <xref
      target="linux-code"/>.</t>

      <section anchor="pracc_motivation"
               title="Motivation: Low Queuing Delay /and/ Full Throughput">
        <t>The Prague CC is capable of keeping queuing delay consistently low
        while fully utilizing available capacity. In contrast, Classic
        congestion controls need to induce a reasonably large queue
        (approaching a bandwidth-delay product) in order to fully utilize
        capacity. Therefore, prior to scalable CCs like DCTCP and Prague, it
        was believed that very low delay was only possible by limiting
        throughput and isolating the low delay traffic from capacity-seeking
        traffic.</t>

        <t>The Prague CC uses additive increase multiplicative decrease
        (AIMD), in which it increases its window until an ECN mark (or loss)
        is detected, then yields in a continual sawtooth pattern. The key to
        keeping queuing delay low without under-utilizing capacity is to keep
        the sawteeth tiny. For example the average duration of a Prague CC
        sawtooth is of the order of a round trip, whereas a classic congestion
        control sawtooths over hundreds of round trips. For instance, over an
        RTT of 36ms, at 100Mb/s CUBIC takes about 106 round trips to recover,
        and at 800 Mb/s its recovery time triples to over 340 round trips, or
        still more than 12 seconds (Reno would take 57 seconds.</t>

        <t>Keeping the sawtooth amplitude down keeps queue variation down and
        utilization up. Keeping the duration of the sawteeth down ensures
        control remains tight. The definition of a scalable CC is that the
        duration between congestion marks does not increase as flow rate
        scales, all other factors being equal. This is important, because it
        means that the sawteeth will always stay tiny. So queue delay will
        remain very low, and control will remain very tight.</t>

        <t>The tip of each sawtooth occurs when the bottleneck link emits a
        congestion signal. Therefore such small sawteeth are only feasible
        when ECN is used for the congestion signals. If loss were used, the
        loss level would be prohibitively high. This is why L4S-ECN has to
        depart from the requirement of Classic ECN<xref target="RFC3168"/>
        that an ECN mark is equivalent to a loss. Because otherwise the
        response to the high level of ECN marking would have to be as great as
        the response to an equivalent level of loss.</t>

        <t>The Prague CC is derived from Data Center TCP (DCTCP <xref
        target="RFC8257"/>). DCTCP is confined to controlled environments like
        data centres precisely because it uses such small sawteeth, which
        induce such a high level of congestion marking. For a CC using Classic
        ECN, this would be interpreted as equivalent to the same, very high,
        loss level. The Classic CC would then continually drive its own rate
        down in the face of such an apparently high level of congestion.</t>

        <t>This is why coexistence with existing traffic is important for the
        Prague CC. It has to be able to detect whether it is sharing the
        bottleneck with Classic traffic, and if so fall back to behaving in a
        Classic way. If the bottleneck does not support ECN at all, that is
        easy - the Prague CC just responds in the Classic way to loss (see
        <xref target="pracc_fallback_loss"/>). But if it is sharing the
        bottleneck with Classic ECN traffic, this is more difficult to detect
        (see <xref target="pracc_fallback_ecn"/>). Because the Prague CC
        removes most of the queue, it also addresses RTT-dependence.
        Otherwise, at low base RTTs, it would become far more RTT-dependent
        than Classic CCs.</t>
      </section>

      <section anchor="pracc_roadmap" title="Document Purpose">
        <t>There is not 'One True Prague CC'. L4S is intended to enable
        development of any scalable CC that meets the L4S Prague requirements
        <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>. This document attempts to
        describe a reference implementation and attempts to generalize it to
        different transports and OS platforms. The implementation does not
        satisfy all the Prague requirements (yet), and the IETF might decide
        that certain requirements need to be relaxed as an outcome of the
        process of trying to satisfy them all.</t>
      </section>

      <section title="Maturity Status (To be Removed Before Publication)">
        <t>The field of congestion control is always a work in progress.
        However, there are areas of the Prague CC that are still just
        placeholders while separate research code is evaluated. And in other
        implementations of the Prague CC, other areas are incomplete. In the
        Linux reference implementation of TCP Prague, interim code is used in
        the incomplete areas, which are:<list style="symbols">
            <t>Flow start and restart (standard slow start is used, even
            though it often exits early in L4S environments were ECN marking
            tends to be frequent);</t>

            <t>Faster than additive increase (standard additive increase is
            used, which makes the flow particularly sluggish if it has dropped
            out of slow start early).</t>
          </list>The body of this document describes the Prague CC as
        implemented. Any non-default options or any planned improvements are
        separated out into <xref target="pracc_future_work"/> on "Variants and
        Future Work". As each of the above areas is addressed, it will will be
        removed from this section and its description in the body of the
        document will be updated. Once all areas are complete, this section
        will be removed. Prague CC will then still be a work in progress, but
        only on a similar footing as all other congestion controls.</t>
      </section>

      <section anchor="pracc_Terminology" title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"/> when, and only when, they appear in all capitals,
        as shown here.</t>

        <t>Definitions of terms:<list style="hanging">
            <t hangText="Classic Congestion Control:">A congestion control
            behaviour that can co-exist with standard TCP Reno <xref
            target="RFC5681"/> without causing significantly negative impact
            on its flow rate <xref target="RFC5033"/>. With Classic congestion
            controls, as flow rate scales, the number of round trips between
            congestion signals (losses or ECN marks) rises with the flow rate.
            So it takes longer and longer to recover after each congestion
            event. Therefore control of queuing and utilization becomes very
            slack, and the slightest disturbance prevents a high rate from
            being attained <xref target="RFC3649"/>.</t>

            <t hangText="Scalable Congestion Control:">A congestion control
            where the average time from one congestion signal to the next (the
            recovery time) remains invariant as the flow rate scales, all
            other factors being equal. This maintains the same degree of
            control over queueing and utilization whatever the flow rate, as
            well as ensuring that high throughput is robust to disturbances.
            For instance, DCTCP averages 2 congestion signals per round-trip
            whatever the flow rate. For the public Internet a Scalable
            transport has to comply with the requirements in Section 4
            of&nbsp;<xref target="I-D.ietf-tsvwg-ecn-l4s-id"/> (aka. the
            'Prague L4S requirements').</t>

            <t hangText="Response function:">The relationship between the
            window (cwnd) of a congestion control and the congestion
            signalling probability, p, in steady state. A general response
            function has the form cwnd = K/p^B, where K and B are constants.
            In an approximation of the response function of the standard Reno
            CC, B=1/2. For a scalable congestion control B=1, so its response
            function takes the form cwnd = K/p. The number of congestion
            signals per round is p*cwnd, which equates to the constant, K, for
            a scalable CC. Hence the definition of a scalable CC above.</t>

            <t hangText="Reno-friendly:">The subset of Classic traffic that
            excludes unresponsive traffic and excludes experimental congestion
            controls intended to coexist with Reno but without always being
            strictly friendly to it (as allowed by <xref target="RFC5033"/>).
            Reno-friendly is used in place of 'TCP-friendly', given that the
            TCP protocol is used with many different congestion control
            behaviours.</t>

            <t hangText="Classic ECN:">The original Explicit Congestion
            Notification (ECN) protocol <xref target="RFC3168"/>, which
            requires ECN signals to be treated the same as drops, both when
            generated in the network and when responded to by the
            sender.<vspace blankLines="1"/>The names used for the four
            codepoints of the 2-bit IP-ECN field are as defined in <xref
            target="RFC3168"/>: Not ECT, ECT(0), ECT(1) and CE, where ECT
            stands for ECN-Capable Transport and CE stands for Congestion
            Experienced.<vspace blankLines="1"/>A packet marked with the CE
            codepoint is termed 'ECN-marked' or sometimes just 'marked' where
            the context makes ECN obvious.</t>

            <t hangText="CC:">Congestion Control</t>

            <t hangText="ACK:">an ACKnowledgement, or to ACKnowledge</t>

            <t hangText="EWMA:">Exponentially Weighted Moving Average</t>

            <t hangText="RTT:">Round Trip Time</t>
          </list></t>

        <t>Definitions of Parameters and Variables:<list style="hanging">
            <t hangText="MTU_BITS:">Maximum transmission unit [b]</t>

            <t hangText="cwnd:">Congestion window [B]</t>

            <t hangText="ssthresh:">Slow start threshold [B]</t>

            <t hangText="inflight:">The amount of data that the sender has
            sent but not yet received ACKs for [B]</t>

            <t hangText="p:">Steady-state probability of drop or marking
            []</t>

            <t hangText="alpha:">EWMA of the ECN marking fraction []</t>

            <t hangText="acked_sacked:">the amount of new data acknowledged by
            an ACK [B]</t>

            <t hangText="ece_delta:">the amount of newly acknowledged data
            that was ECN-marked [B]</t>

            <t hangText="ai_per_rtt:">additive increase to apply per RTT
            [B]</t>

            <t hangText="srtt:">Smoothed round trip time [s]</t>

            <t hangText="MAX_BURST_DELAY:">Maximum allowed bottleneck queuing
            delay due to segmentation offload bursts [s] (default 0.25 ms for
            the public Internet)</t>
          </list></t>
      </section>
    </section>

    <section anchor="pracc_prague_cc" title="Prague Congestion Control">
      <t/>

      <section anchor="pracc_Prague_L4S_reqs"
               title="The Prague L4S Requirements">
        <t>The beneficial properties of L4S traffic (low queuing delay, etc.)
        depend on all L4S sources satisfying a set of conditions called the
        Prague L4S Requirements. The name is after an ad hoc meeting of about
        thirty people co-located with the IETF in Prague in July 2015, the day
        after the first public demonstration of L4S.</t>

        <t>The meeting agreed a list of modifications to DCTCP <xref
        target="RFC8257"/> to focus activity on a variant that would be safe
        to use over the public Internet. it was suggested that this could be
        called TCP Prague to distinguish it from DCTCP. This list was adopted
        by the IETF, and has continued to evolve (see section 4 of <xref
        target="I-D.ietf-tsvwg-ecn-l4s-id"/>). The requirements are no longer
        TCP-specific, applying irrespective of wire-protocol (TCP, QUIC, RTP,
        SCTP, etc).</t>

        <t>This unusual start to the life of the project led to the unusual
        development process of a reference implementation that had to resolve
        a number of ambitious requirements, already known to be in tension
        <xref target="Tensions17"/>.</t>

        <t>DCTCP already implements a scalable congestion control. So most of
        the changes to make it usable over the Internet seemed trivial, some
        'merely' involving adoption of other parallel developments like
        Accurate ECN TCP feedback or RACK. Others have been more challenging
        (e.g. RTT-independence). And others that seemed trivial became
        challenging given the complex set of bugs and behaviours that
        characterize today's Internet and the Linux stack.</t>

        <t>The more critical implementation challenges are highlighted in the
        following sections, in the hope we can prevent mistakes being repeated
        (see for instance <xref target="pracc_moving_avg"/>, <xref
        target="pracc_MD"/>). There was also a set of five intertwined 'bugs'
        - all masking each other, but causing unpredictable or poor
        performance as different code modifications unmasked them. A draft
        write-up about these has been prepared, which is longer than the whole
        of the present document, so it will be included by reference once
        published.</t>

        <t>During the development process, we have unearthed fundamental
        aspects of the implementation and indeed the design of DCTCP and
        Prague that have still not caught up with the paradigm shift from
        existence to extent-based congestion response. Some have been
        implemented by default, e.g. not suppressing additive increase for a
        round trip after a congestion event (<xref target="pracc_AI"/>).
        Others have been implemented but not fully evaluated, e.g. removing
        the 1-2 unnecessary round trips of lag in feedback processing (<xref
        target="pracc_faster_response"/>) and yet others are still future
        plans, e.g. further RTT-independence (<xref
        target="pracc_further_rtt_independence"/>) and exploiting combined
        congestion metrics in more cases (<xref
        target="pracc_combining_metrics"/>).</t>

        <t>The requirements are categorized into those that would impact other
        flows if not handled properly and performance optimizations that are
        important but optional from the IETF's point of view, because they
        only affect the flow itself. The list below maps the order of the
        requirements in <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/> to the
        order in this document (which is by functional categories and code
        status): <list style="hanging">
            <t hangText="Mandatory or Advisory Requirements:"><list
                style="symbols">
                <t>L4S-ECN packet identification: use of ECT(1) (<xref
                target="pracc_pkt_id"/>)</t>

                <t>Accurate ECN feedback (<xref
                target="pracc_accecn_fb"/>)</t>

                <t>Reno-friendly response to a loss (<xref
                target="pracc_fallback_loss"/>)</t>

                <t>Detection of a classic ECN AQM (<xref
                target="pracc_fallback_ecn"/>)</t>

                <t>Reduced RTT dependence (<xref
                target="pracc_rtt_independence"/>)</t>

                <t>Scaling down to a fractional window (no longer mandatory,
                see <xref target="pracc_fractional_windows"/>)</t>

                <t>Detecting loss in units of time (<xref
                target="pracc_loss_in_time"/>)</t>

                <t>Minimizing bursts (<xref target="pracc_pacing"/></t>
              </list></t>

            <t hangText="Optional performance optimizations:"><list
                style="symbols">
                <t>ECN-capable control packets (<xref
                target="pracc_pkt_id"/>)</t>

                <t>Faster flow start (<xref
                target="pracc_flow_start_future"/>)</t>

                <t>Faster than additive increase (<xref
                target="pracc_faster_ai"/>)</t>

                <t>Segmentation offload (<xref target="pracc_offload"/>)</t>
              </list></t>
          </list></t>

        <t/>
      </section>

      <section anchor="pracc_pkt_id" title="Packet Identification">
        <t>On the public Internet, a sender using the Prague CC MUST set the
        ECT(1) codepoint on all the packets it sends, in order to identify
        itself as an L4S-capable congestion control (Req 4.1 <xref
        target="I-D.ietf-tsvwg-ecn-l4s-id"/>).</t>

        <t>This applies whatever the transport protocol, whether TCP, QUIC,
        RTP, etc. In the case of TCP, unlike an RFC 3168 TCP ECN transport, a
        sender can set all packets as ECN-capable, including TCP control
        packets and retransmissions <xref target="RFC8311"/>, <xref
        target="I-D.ietf-tcpm-generalized-ecn"/>.</t>

        <t>The Prague CC SHOULD optionally be configurable to use the ECT(0)
        codepoint in private networks, such as data centres, which might be
        necessary for backward compatibility with DCTCP deployments where
        ECT(1) might already have another usage.</t>

        <t>Implementation note:<list style="hanging">
            <t hangText="TCP Prague in Linux  kernel:">The kernel was updated
            to allow the ECT(1) flag to be set from within a CC module. The
            Prague CC then has full control over the ECN code point it uses at
            any one time. In this way it enforces the use of ECT(1) (or
            optionally ECT(0)) and non-ECT when required.</t>
          </list></t>
      </section>

      <section title="Detecting and Measuring Congestion">
        <t/>

        <section anchor="pracc_accecn_fb" title="Accurate ECN Feedback">
          <t>When feedback of ECN markings was added to TCP <xref
          target="RFC3168"/>, it was decided not to report any more than one
          mark per RTT. L4S-capable congestion controls need to know the
          extent, not just the existence of congestion (Req 4.2. <xref
          target="I-D.ietf-tsvwg-ecn-l4s-id"/>). Recently defined transports
          (DCCP, QUIC, etc) typically already satisfy this requirement. So
          they are dealt with separately below, while TCP and derivatives such
          as SCTP <xref target="RFC4960"/> are covered first.</t>

          <section title="Accurate ECN Feedback with TCP &amp; Derivatives">
            <t>The TCP wire protocol is being updated to allow more accurate
            feedback (AccECN <xref target="I-D.ietf-tcpm-accurate-ecn"/>).
            Therefore, in the case where a sender uses the Prague CC over TCP,
            whether as client or server:<list style="symbols">
                <t>it MUST itself support AccECN;</t>

                <t>to support AccECN it also has to check that its peer
                supports AccECN during the handshake.</t>
              </list>If the peer does not support accurate ECN feedback, the
            sender MUST fall back to a Reno-friendly CC behaviour for the rest
            of the connection. The non-Prague TCP sender MUST then no longer
            set ECT(1) on the packets it sends. Note that the peer only needs
            to support AccECN; there is no need (and no way) to find out
            whether the peer is using an L4S-capable congestion control.</t>

            <t>Note that a sending TCP client that uses the Prague CC can set
            ECT(1) on the SYN prior to checking whether the other peer
            supports AccECN (as long as it follows the procedure in <xref
            target="I-D.ietf-tcpm-generalized-ecn"/> if it discovers the peer
            does not support AccECN).</t>

            <t>Implementation note:<list style="hanging">
                <t hangText="TCP Prague in Linux  kernel:">The kernel had been
                updated to support AccECN Independent of the CC module in use.
                So the kernel tries to negotiate AccECN exchange whichever
                congestion control module is selected. An additional check is
                provided to verify that the kernel actually does support
                AccECN, based on which the Prague CC module will decide to
                proceed using scalable CC or fall back to a Classic CC (Reno
                in the current implementation).<vspace blankLines="1"/>A
                system wide option is available to disable AccECN negotiation,
                but the Prague CC module will always override this setting, as
                it depends on AccECN. Then, solely in this case, AccECN will
                only be active for TCP flows using the Prague CC.</t>
              </list></t>
          </section>

          <section title="Accurate ECN Feedback with Other Modern Transports">
            <t>Transport protocols specified recently, .e.g. DCCP <xref
            target="RFC4340"/>, QUIC <xref target="I-D.ietf-quic-transport"/>,
            are unambiguously suitable for Prague CCs, because they were
            designed from the start with accurate ECN feedback.</t>

            <t>In the case of RTP/RTCP, ECN feedback was added in <xref
            target="RFC6679"/>, which is sufficient for the Prague CC.
            However, it is preferable to use the most recent improvements to
            ECN feedback in <xref
            target="I-D.ietf-avtcore-cc-feedback-message"/>, as used in the
            implementation of the L4S variant of SCReAM <xref
            target="RFC8298"/>.</t>
          </section>
        </section>

        <section anchor="pracc_moving_avg"
                 title="Moving Average of ECN Feedback">
          <t>The Prague CC currently maintains a moving average of ECN
          feedback in a similar way to DCTCP. This section is provided mainly
          because performance has proved to be sensitive to implementation
          precision in this area. So first, some background is necessary.</t>

          <t>The Prague CC triggers update of its moving average once per RTT
          by recording the packet it sent after the previous update, then
          watching for the ACK of that packet to return. To maintain its
          moving average, it measures the fraction, frac, of ACKed bytes that
          carried ECN feedback over the previous round trip. It then updates
          an exponentially weighted moving average (EWMA) of this fraction,
          called alpha, using the following algorithm:<list style="empty">
              <t>alpha += g * (frac - alpha);</t>
            </list>where g is the gain of the EWMA (default 1/16).</t>

          <t>Implementation notes:<list style="hanging">
              <t hangText="Rounding problems in DCTCP:">Alpha is a fraction
              between 0 and 1, and it needs to be represented with high
              resolution because the larger the bandwidth-delay product (BDP)
              of a flow, the smaller the value that alpha converges to (in
              steady state alpha = 2/cwnd). In principle, Linux DCTCP
              maintains the moving average 'alpha' using the same formula as
              Prague CC uses (as above). Linux represents alpha with a 10-bit
              integer (with resolution 1/1024). However, up to kernel release
              3.19, Linux used integer arithmetic that could not reduce alpha
              below 15/1024. Then it was patched so that any value below
              16/1024 was rounded down to zero <xref
              target="patch-alpha-zero"/>. For a flow with a higher BDP than
              128 segments, this means that, alpha flip-flops. Once it has
              flopped down to zero DCTCP becomes unresponsive until it has
              built sufficient queue to flip up to 16/1024. For larger BDPs,
              this causes DCTCP to induce larger sawteeth, which loses the
              low-queuing-delay and high-utilization intent of the
              algorithm.</t>

              <t hangText="Upscaled alpha in Prague CC:">To resolve the above
              problem the implementation of TCP Prague in Linux maintains
              upscaled_alpha = alpha/g instead of alpha:<list style="empty">
                  <t>upscaled_alpha += frac - g * upscaled_alpha;</t>
                </list>This technique is the same as Linux uses for the
              retransmission timer variables, srtt and mdev. Prague CC also
              uses 20 bits for alpha,</t>
            </list></t>

          <t>Currently the above per-RTT update to the moving average, which
          was inherited from DCTCP, is the default in the Prague CC. However,
          another approach is being investigated because these per-RTT updates
          introduce 1--2 rounds of delay into the congestion response on top
          of the inherent round of feedback delay (see <xref
          target="pracc_faster_response"/> in the section on variants and
          future work).</t>
        </section>

        <section anchor="pracc_loss_in_time"
                 title="Scaling Loss Detection with Flow Rate">
          <t>After an ACK leaves a gap in the sequence space, a Prague CC is
          meant to deem that a loss has occurred using 'time-based units' (Req
          4.3. <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>). This is in
          contrast to the traditional approach that counts a hard-coded number
          of duplicate ACKs, e.g. the 3 Dup-ACKs specified in <xref
          target="RFC5681"/>. Counting packets rather than time unnecessarily
          tightens the time within which parallelized links have to keep
          packets in sequence as flow rate scales over the years.</t>

          <t>To satsify this requirement, a Prague CC SHOULD wait until a
          certain fraction of the RTT has elapsed before it deems that the gap
          is due to packet loss. The reference implementation of TCP Prague in
          Linux uses RACK <xref target="I-D.ietf-tcpm-rack"/> to address this
          requirement. An approach similar to TCP RACK is also used in
          QUIC.</t>

          <t>At the start of a connection, RACK counts 3 DupACKs to detect
          loss because the initial smoothed RTT estimate can be inaccurate.
          This would depend indirectly on time as long as the initial window
          (IW) is paced over a round trip (see <xref
          target="pracc_flow_start"/>). For instance, if the initial window of
          10 segments was paced evenly across the initial RTT then, in the
          next round, an implementation that deems there has been a loss after
          (say) 1/4 of an RTT can count 1/4 of 10 = 3 DupACKs (rounded up).
          Subsequently, as the window grows, RACK shifts to using a fraction
          of the RTT for loss detection.</t>
        </section>
      </section>

      <section anchor="pracc_Congestion_response"
               title="Congestion Response Algorithm">
        <t>In congestion avoidance phase, a Prague CC uses a similar additive
        increase multiplicative decrease (AIMD) algorithm to DCTCP, but with
        the following differences:</t>

        <section anchor="pracc_loss_behaviour" title="Loss behaviour">
          <t>A Prague CC MUST use a Reno-friendly congestion response (such as
          that of CUBIC or Reno) on detection of a loss (Req 2 in section 4.3.
          of <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>). DCTCP falls back to
          Reno for the round trip after a loss, and the Linux reference
          implementation of TCP Prague currently inherits this behaviour. On
          detection of loss, an implementation can use CUBIC's behaviour
          instead of Reno's for both the reduction after the loss and the
          subsequent growth of cwnd until the next congestion event.</t>

          <t>If a Prague CC has already reduced the congestion window due to
          ECN feedback less than a round trip before it detects a loss, it MAY
          reduce the congestion window by a smaller amount due to the loss, as
          long as the reductions, due to ECN and the loss, when multiplied
          together result in the reduction that the implementation usually
          makes in response to loss (e.g. 50% to emulate Reno or 30% to
          emulate CUBIC).</t>

          <t>See <xref target="pracc_combining_metrics"/> for discussion of
          future work on congestion control using a combination of delay, ECN
          and loss.</t>

          <t>Implementation note:<list style="hanging">
              <t hangText="DCTCP bug prior to v5.1:">A Prague CC cannot rely
              on the fall-back-on-loss behaviour of the DCTCP code in the
              Linux kernel prior to v5.1, due to a previous bug in the fast
              retransmit code (but not in the retransmission timeout code)
              <xref target="patch-loss-react"/>.</t>
            </list></t>
        </section>

        <section anchor="pracc_MD"
                 title="Multiplicative Decrease on ECN Feedback">
          <t>The Prague CC currently responds to ECN feedback in a similar way
          to DCTCP. This section is provided mainly because performance has
          proved to be sensitive to implementation details in this area. So
          the following recap of the congestion response is needed first.</t>

          <t>As explained in <xref target="pracc_moving_avg"/>, the Prague CC
          (like DCTCP) clocks its moving average of ECN-marking, alpha, once
          per round trip throughout a connection. Nonetheless, it only
          triggers a multiplicative decrease to its congestion window when it
          actually receives an ACK carrying ECN feedback. Then it suppresses
          any further decreases for one round trip, even if it receives
          further ECN feedback. This is termed Congestion Window Reduced or
          CWR state.</t>

          <t>The Prague CC (like DCTCP) ensures that the average recovery time
          remains invariant as flow rate scales (Req 4.3 of <xref
          target="I-D.ietf-tsvwg-ecn-l4s-id"/>) by making the multiplicative
          decrease depend on the prevailing value of alpha as follows:<list
              style="empty">
              <t>ssthresh = (1 - alpha/2) * cwnd;</t>
            </list></t>

          <t>Implementation notes:<list style="hanging">
              <t hangText="Upscaled alpha:">With reference to the earlier
              discussion of integer arithmetic precision (<xref
              target="pracc_moving_avg"/>), alpha = g * upscaled_alpha.</t>

              <t hangText="Carry of fractional cwnd remainder:">Typically the
              absolute reduction in the window is only a small number of
              segments. So, if the Prague CC implementation counts the window
              in integer segments (as in the Linux reference code), delay can
              be made significantly less jumpy by tracking a fractional value
              alongside the integer window and carrying over any fractional
              remainder to the next reduction. Also, integer rounding bias
              ought to be removed from the multiplicative decrease
              calculation.</t>
            </list></t>

          <t>In dynamic scenarios, as flows find a new operating point, alpha
          will have often tailed away to near-nothing before the onset of
          congestion. Then DCTCP's tiny reduction followed by no further
          response for a round is precisely the wrong way for a CC to respond.
          A solution to this problem is being evaluated as part of the work
          already mentioned to improve Prague's responsiveness (see <xref
          target="pracc_faster_response"/> in the section on variants and
          future work).</t>
        </section>

        <section anchor="pracc_AI" title="Additive Increase and ECN Feedback">
          <t>Unlike DCTCP, the Prague CC does not suppress additive increase
          for one round trip after a congestion window reduction (while in CWR
          state). Instead, a Prague CC applies additive increase irrespective
          of its CWR state, but only for bytes that have been ACK'd without
          ECN feedback. Specifically, on each ACK,<figure>
              <artwork><![CDATA[    cwnd += (acked_sacked - ece_delta) * ai_per_rtt / cwnd;
]]></artwork>
            </figure>where:<list style="empty">
              <t>acked_sacked is the number of new bytes acknowledged by the
              ACK;</t>

              <t>ece_delta is the number of newly acknowledge ECN-marked
              bytes;</t>

              <t>ai_per_rtt is a scaling factor that is typically 1 SMSS
              except for small RTTs (see <xref
              target="pracc_rtt_independence"/>)</t>
            </list></t>

          <t>Superficially, the traditional suppression of additive increase
          for the round after a decrease seems to make sense. However, DCTCP
          and Prague are designed to induce an average of 2 congestion marks
          per RTT in steady state, which leaves very little space for any
          increase between the end of one round of CWR and the next mark. In
          tests, when a test version of Prague CC is configured to completely
          suppress additive increase during CWR (like Reno and DCTCP), it
          sawteeth become more irregular, which is its way of making some
          decreases large enough to open up enough space for an increase. This
          irregularity tends to reduce link utilization. Therefore, the
          reference Prague CC continues additive increase irrespective of CWR
          state.</t>

          <t>Nonetheless, rather than continue additive increase regardless of
          congestion, it is safer to only increase on those ACKs that do not
          feed back congestion. This approach reduces additive increase as the
          marking probability increases, which tends to keep the marking level
          unsaturated (below 100%) (see Section 3.1 of <xref
          target="Tensions17"/>). Under stable conditions, Prague's congestion
          window then becomes proportional to (1-p)/p, rather than 1/p.</t>

          <t>See also 'Faster than Additive Increase' (<xref
          target="pracc_faster_ai"/>)</t>
        </section>

        <section anchor="pracc_rtt_independence"
                 title="Reduced RTT-Dependence">
          <t>The window-based AIMD described so far was inherited from Reno
          via DCTCP. When many long-running Reno flows share a link, their
          relative packet rates become roughly inversely proportional to RTT
          (packet rate =~ 1/RTT). Then a flow with very small RTT will
          dominate any flows with larger RTTs.</t>

          <t>Queuing delay sets a lower limit to the smallest possible RTT.
          So, prior to the extremely low queuing delay of L4S, extreme cases
          of RTT dependence had never been apparent. Now that L4S has removed
          most of the queuing delay, we have to address the root-cause of
          RTT-dependence, which the Prague CC is required to do, at least when
          the RTT is small (see the 'Reduced RTT bias' aspect of Req 4.3.
          <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>). Here, a small RTT is
          defined as below the typical RTT for the intended deployment
          environment.</t>

          <t>The reference Prague CC reduces RTT bias by using a virtual RTT
          (rtt_virt) rather than the actual round trip (rtt) for all three of:
          the period of additive window increase; the EWMA update period; and
          the duration of CWR state after a decrease. rtt_virt is a function
          of the actual RTT. The function is chosen so that, when the actual
          RTT is high, the virtual RTT is essentially equal to the actual RTT;
          but for lower actual RTTs, the virtual RTT is increasingly larger
          than the actual RTT. Example functions for the virtual RTT are:<list>
              <t>rtt_virt = max(rtt, RTT_VIRT_MIN);</t>

              <t>rtt_virt = rtt + AdditionalRTT; </t>

              <t/>
            </list>where RTT_VIRT_MIN and AdditionalRTT are constants. The
          current default is rtt_virt = max(rtt, 25ms), which addresses the
          main Prague requirement for when the RTT is smaller than
          typical.</t>

          <t>As the actual window (cwnd) is still sent within 1 actual RTT, we
          also need to use a (conceptual) virtual window, cwnd_virt. For
          instance, if rtt_virt = 25 ms then, when the actual RTT is 5 ms,
          there are rtt_virt/rtt = 5 times more packets in cwnd_virt, than in
          the actual window, cwnd, because it spans 5 actual round trips. We
          define M as the ratio rtt_virt/rtt.<!--ToDo: Say what the reference values are not used for:
* cwnd_ref is not used for regulating the sending of packets (i.e. Prague still uses the min  of cwnd and rwnd)

RTT_ref is /not/ used for:
* retransmission timers (i.e. RTT is still used)--></t>

          <t>In Reno or DCTCP, additive increase is implemented by dividing
          the desired increase of 1 segment per round over the cwnd packets in
          the round. This requires an increase of 1/cwnd per packet. In the
          Linux implementation of TCP Prague, the aim is to increase the
          reference window by 1 segment over a virtual RTT. However, in
          practice the increase is applied to the actual window, cwnd, which
          is M times smaller than cwnd_virt. So cwnd has to be increased by
          only 1/M segments over rtt_virt. But again, in practice, the
          increase is applied over an actual window of packets spanning an
          actual RTT, which is also M times smaller than the virtual RTT. So
          the desired increase in cwnd is only 1/M^2 segments over an actual
          round trip containing cwnd packets. Therefore, the increase in cwnd
          per packet has to be (1/M^2) * (1/cwnd).</t>

          <t>Unless a flow lasts long enough for rates to converge, equal
          rates will not be relevant. So, the Reduced RTT-Dependence algorithm
          only comes into effect after D rounds, where D is configurable
          (current default 500). Continuing the previous example, if actual
          rtt=5 ms and rtt_virt = 25 ms, then Prague would stop using its
          RTT-dependent algorithm after 500*5ms = 2.5s and instead it would
          start to converge to equal rates using the Reduced RTT-Dependence
          algorithm. If the actual RTT were higher (e.g. 20ms), it would stay
          in RTT-dependent mode for longer (10s), but this would be mitigated
          by its RTT being closer to the reference (20ms vs. 25ms).</t>

          <t>This approach prevents reduced RTT-dependence from making the
          flow less responsive at start-up and ensures that its early
          throughput share is based on its actual RTT. The benefit is that
          short flows (mice) give themselves priority over longer flows
          (elephants), and shorter RTTs will still converge faster than longer
          RTTs. Nonetheless, the throughput still converges to equal rates
          after D rounds.</t>

          <t>It is planned to reset the algorithm to be RTT-dependent after an
          idle, not just at flow start, as discussed under Future Work in
          <xref target="pracc_further_rtt_independence"/>.</t>

          <t><xref target="pracc_further_rtt_independence"/> also discusses
          extending the reduction in RTT-dependence to longer RTTs than
          RTT_VIRT_MIN (i.e. longer than 25ms). The current Prague
          implementation does not support this.</t>
        </section>

        <section anchor="pracc_flow_start" title="Flow Start or Restart">
          <t>Currently the Linux reference implementation of TCP Prague uses
          the standard Linux slow start code. Slow start is exited once a
          single mark is detected.</t>

          <t>When other flows are actively filling the link, regular marks are
          expected, causing slow start of new flows to end prematurely. This
          is clearly not ideal, so other approaches are being worked on (see
          <xref target="pracc_flow_start_future"/>). However, slow start has
          been left as the default until a properly matured solution is
          completed.</t>
        </section>
      </section>

      <section title="Packet Sending">
        <t/>

        <section anchor="pracc_pacing" title="Packet Pacing">
          <t>The Prague CC SHOULD pace the packets it sends to avoid the
          queuing delay and under-utilization that would otherwise be caused
          by bursts of packets that can occur, for example, when a jump in the
          acknowledgement number opens up cwnd. Prague does this in a similar
          way to the base Linux TCP stack, by spacing out the window of
          packets evenly over the round trip time, using the following
          calculation of the pacing rate [b/s]:<list style="empty">
              <t>pacing_rate = MTU_BITS * max(cwnd, inflight) / srtt;</t>
            </list></t>

          <t>During slow start, as in the base Linux TCP stack, Prague factors
          up pacing_rate by 2, so that it paces out packets twice as fast as
          they are acknowledged. This keeps up with the doubling of cwnd, but
          still prevents bursts in response to any larger transient jumps in
          cwnd.<figure>
              <artwork><![CDATA[    if (cwnd < ssthresh / 2)
        pacing_rate *= 2;
]]></artwork>
            </figure></t>

          <t>During congestion avoidance, the Linux TCP Prague implementation
          does not factor up pacing_rate at all. This contrasts with the base
          Linux TCP stack, which currently factors up pacing_rate by a ratio
          parameter set to 1.2. The developers of the base Linux stack
          confirmed that this factor of 1.2 was only introduced in case it
          improved performance, but there were no scenarios where it was known
          to be needed. In testing of Prague, this factor was found to cause
          queue delay spikes whenever cwnd jumped more than usual. And
          throughput was no worse without it. So it was removed from the TCP
          Prague CC.</t>

          <t>The Prague CC can use alternatives to the traditional slow-start
          algorithm, which use different pacing (see <xref
          target="pracc_flow_start"/>).</t>
        </section>

        <section anchor="pracc_offload" title="Segmentation Offload">
          <t>In the absence of hardware pacing, it becomes increasingly
          difficult for a machine to scale to higher flow rates unless it is
          allowed to send packets in larger bursts, for instance using
          segmentation offload. Happily, as flow rate scales up,
          proportionately more packets can be allowed in a burst for the same
          amount of queuing delay at the bottleneck.</t>

          <t>Therefore, the Prague CC sends packets in a burst as long as it
          will not induce more than MAX_BURST_DELAY of queuing at the
          bottleneck. From this constant and the current pacing_rate, it
          calculates how many MTU-sized packets to allow in a burst:<list
              style="empty">
              <t>max_burst = pacing_rate * MAX_BURST_DELAY / MTU_BITS</t>
            </list>The current default in the Linux TCP Prague for
          MAX_BURST_DELAY is 250us which supports marking thresholds starting
          from about 500us without underutilization. This approach is similar
          to that in the Linux TCP stack, except there MAX_BURST_DELAY is
          1ms.</t>
        </section>
      </section>
    </section>

    <!--ToDo: RFC5033 lists subjects that the spec of an alternative CC should cover.-->

    <section anchor="pracc_future_work" title="Variants and Future Work">
      <t/>

      <section title="Getting up to Speed Faster">
        <t>Appendix A.2. of <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>
        outlines the performance optimizations needed when transplanting DCTCP
        from a DC environment to a wide area network. The following
        subsections address two of those points: faster flow startup and
        faster than additive increase. Then <xref
        target="pracc_faster_response"/> covers the flip side, in which
        established flows have to yield faster to make room, otherwise queuing
        will result.</t>

        <section anchor="pracc_flow_start_future"
                 title="Flow Start (or Restart)">
          <t>The Prague performance For faster flow start, two approaches are
          currently being investigated in parallel:<list style="hanging">
              <t hangText="Modified Slow Start:">The traditional exponential
              slow start can be modified both at the start and the end, with
              the aim of reducing the risk of queuing due to bursts and
              overshoot:<list style="hanging">
                  <t hangText="Pacing IW:">A Prague CC can use an initial
                  window of 10 (IW10 <xref target="RFC6928"/>), but pacing of
                  this Initial Window is recommended to try to avoid the pulse
                  of queuing that could otherwise occur. Pacing IW10 also
                  spreads the ACKs over the round trip so that subsequent
                  rounds consist of ten subsets of packets (with 2, 4, 8 etc.
                  per round in each subset), rather than a single set with 20,
                  40, 80 etc. in each round. With IW paced, if a queue builds
                  during a round (e.g. due to other unexpected traffic
                  arriving) it can drain in the gap before the next subset,
                  rather than the whole set backing up into a much larger
                  queue. As smoothed RTT is unknown or inaccurate at the start
                  of a flow, an implementation can pace IW over a fraction of
                  the initial smoothed RTT (perhaps also clamped between
                  hard-coded sanity limits). The implementation could also
                  initialize SRTT with a value it had previously cached per
                  destination (as long as it is sufficiently fresh). The
                  safety factor could depend on whether a cached value was
                  available and how recent it was.<vspace blankLines="1"/>In
                  the Linux reference implementation of TCP Prague, IW pacing
                  can be optionally enabled, but it is off by default, because
                  it is yet to be fully evaluated. It currently paces IW over
                  half the initial smoothed round trip time (SRTT) measured
                  during the handshake. SRTT is halved because the RTT often
                  reduces after the initial handshake. For example: i) some
                  CDNs move the flow to a closer server after establishment;
                  ii) the initial RTT from a server can include the time to
                  wake a sleeping handset battery; iii) some uplink
                  technologies take a link-level round trip to request a
                  scheduling slot.<vspace blankLines="1"/>It is also planned
                  to exploit any cached knowledge of the path RTT to improve
                  the initial estimate, for instance using the Linux
                  per-destination cache. it is also planned to allow the
                  application to give an RTT hint (by setting
                  sk_max_pacing_rate in Linux) if the developer has reason to
                  believe that the application has a better estimate.</t>

                  <t hangText="Exiting slow start more gracefully:">In the
                  wide area Internet (in contrast to data centres), bottleneck
                  access links tend to have much less capacity than the line
                  rate of the sender. With a shallow immediate ECN threshold
                  at this bottleneck, the slightest burst can tend to induce
                  an ECN mark, which traditionally causes slow start to exit.
                  A more gradual exit is being investigated for a Prague CC
                  using the extent of marking, not just the existence of a
                  single mark. This will be more consistent with the
                  extent-based marking that scalable congestion controls use
                  during congestion avoidance. Delay measurements (similar to
                  Hystart++ <xref target="I-D.ietf-tcpm-hystartplusplus"/>)
                  can also be used to complement the ECN signals.</t>
                </list></t>

              <t hangText="Paced Chirping:">In this approach, the aim is to
              both increase more rapidly than exponential slow-start and to
              greatly reduce any overshoot. It is primarily a delay-based
              approach, but the aim is also to exploit ECN signals when
              present (while not forgetting loss either). Therefore Paced
              Chirping is generally usable for any congestion control - not
              solely for Prague CC and L4S.<vspace blankLines="1"/>Instead of
              only aiming to detect capacity overshoot at the end of
              flow-start, brief trains of rapidly decreasing inter-packet
              spacing called chirps are used to test many rates with as few
              packets and as little load as possible. A full description is
              beyond the scope of this document. <xref
              target="LinuxPacedChirping"/> introduces the concepts and the
              code as well as citing the main papers on Paced Chirping.<vspace
              blankLines="1"/>Paced chirping works well over continuous links
              such as Ethernet and DSL. But better averaging and noise
              filtering are necessary over discontinuous link technologies
              such as WiFi, LTE cellular radio, passive optical networks (PON)
              and data over cable (DOCSIS). This is the current focus of this
              work.<vspace blankLines="1"/>The current Linux implementation of
              TCP Prague does not include Paced Chirping, but research code is
              available separately in Linux and ns3. it is accessible via the
              L4S landing page <xref target="L4S-home"/>.</t>
            </list></t>
        </section>

        <section anchor="pracc_faster_ai"
                 title="Faster than Additive Increase">
          <t>The Prague CC has a startup phase and congestion avoidance phase
          like traditional CCs. In steady-state during congestion avoidance,
          like all scalable congestion controls, it induces frequent ECN
          marks, with the same average recovery time between ECN marks, no
          matter how much the flow rate scales.</t>

          <t>If available capacity suddenly increases, e.g. other flow(s)
          depart or the link capacity increases, these regular ECN marks will
          stop. Therefore after a few rounds of silence (no ECN marks) in
          congestion avoidance phase, the Prague CC can assume that available
          capacity has increased, and switch to using the techniques from its
          startup phase (<xref target="pracc_flow_start_future"/>) to rapidly
          find the new, faster operating point. Then it can shift back into
          its congestion avoidance behaviour.</t>

          <t>That is the theory. But, as explained in <xref
          target="pracc_flow_start_future"/>, the startup techniques,
          specifically paced chirping, are still being developed for
          discontinuous link types. Once the startup behaviour is available,
          the Linux implementation of the Prague CC will also have a faster
          than additive increase behaviour. S.3.2.3 of <xref
          target="PragueLinux"/>) gives a brief preview of the performance of
          this approach over an Ethernet link type in ns3.</t>
        </section>

        <section anchor="pracc_faster_response"
                 title="Remove Lag in Congestion Response">
          <t>To keep queuing delay low, new flows can only push in fast if
          established flows yield fast. It has recently been realized that the
          design of the Prague EWMA and congestion response introduces 1-2
          rounds of lag (on top of the inherent round of feedback delay due to
          the speed of light). These lags were inherited from the design of
          DCTCP (see <xref target="pracc_moving_avg"/> and <xref
          target="pracc_MD"/>), where a couple of extra hundred microseconds
          was less noticeable. But congestion control in the wide area
          Internet cannot afford up to 2 rounds trips of extra lag.</t>

          <t>To be clear, lag means delay before any response at all starts.
          That is qualititatively different from the smoothing gain of an
          EWMA, which /reduces/ the response by the gain factor (1/16 by
          default) in case a change in congestion does not persist. Smoothing
          gain can always be increased. But 1-2 rounds of lag means that, when
          a new flow tries to push in, the sender of an established flow will
          not respond /at all/ for 1-2 rounds after it first receives
          congestion feedback.</t>

          <t>The Prague CC spends the first round trip of this lag gathering
          feedback to measure frac before it is input into the EWMA algorithm
          (see <xref target="pracc_moving_avg"/>). Then there is up to one
          further round of delay because the implementations of DCTCP and
          Prague did not fully adopt the paradigm shift to extent-based
          marking - the timing of the decrease is still based on Reno.</t>

          <t>Both Reno and DCTCP/Prague respond immediately on the first sign
          of congestion. Reno's response is large, so it waits a round in CWR
          state to allow the response to take effect. DCTCP's response is tiny
          (extent-based), but then it still waits a round in CWR state. So it
          does next-to-nothing for a round.</t>

          <t>New EWMA and resposne algorithms to remove these 1-2 extra rounds
          of lag are described in <xref target="PerAckEWMA"/>. They have been
          implemented in Linux and an iterative process of evaluation and
          redesign is in progress. The EWMA is updated per-ACK, but it still
          changes as if it is clocked per round trip. The congestion response
          is still triggered by the first indication of ECN feedback, but it
          proceeds over the subsequent round trip so that it can take into
          account further incoming feedback as the EWMA evolves. The reduction
          is applied per-ACK but sized to result as if it had been a single
          response per round trip.</t>
        </section>
      </section>

      <section anchor="pracc_combining_metrics"
               title="Combining Congestion Metrics">
        <t>Ultimately, it would be preferable to take an integrated approach
        and use a combination of ECN, loss and delay metrics to drive
        congestion control. For instance, using a downward trend in ECN
        marking and/or delay as a heuristic to temper the response to loss.
        Such ideas are not in the immediate plans for the Linux TCP Prague,
        but some more specific ideas are highlighted in the following
        subsections.</t>

        <section title="ECN with Loss">
          <t>If the bottleneck is ECN-capable, a loss due to congestion is
          very likely to have been preceded by a period of ECN marking. When
          the current Linux TCP Prague CC detects a loss, like DCTCP, it
          halves cwnd, even if it has already reduced cwnd in the same round
          trip due to ECN marking. This double reduction can end up factoring
          down cwnd to as little as 1/4 in one round trip.</t>

          <t>On a loss while in CWR state following an ECN reduction, for an
          implementation that uses Reno response, it would be possible to use
          a decrease factor of 1/(2-alpha), which would compound with the
          previous decrease factor of (1-alpha/2) to result in a factor of: (1
          - alpha/2) / (2-alpha)) = 1/2. In integer arithmetic, this division
          would be possible but relatively expensive. A less expensive
          alternative would be a decrease factor of (2+alpha)/4, which
          approximates to a compounded decrease factor of 1/2 for typical low
          values of alpha, even up to 30%. The compound decrease factor is
          never greater than 1/2 and in the worst case, if alpha were 100%, it
          is 3/8.</t>

          <t>If an implementation uses a CUBIC response on loss after an ECN
          reduction in the same round trip, it can use a multiplicative
          decrease factor of 7/(5*(2-alpha)) which would result in a combined
          reduction to 7/10 of the previous cwnd, as intended for CUBIC.</t>
        </section>

        <section title="ECN with Delay">
          <t><xref target="pracc_faster_ai"/> described the plans to shift
          between using ECN when close to the operating point and using delay
          by injecting paced chirps to find a new operating after the ECN
          signal goes silent for a few rounds. Paced chirping shifts more
          slowly to the new operating point the more noise there is in the
          delay measurements. Work is ongoing on treating any ECN marking as a
          complementary metric. The resulting less noisy combined metric
          should then allow the controller to shift more rapidly to each new
          operating point.</t>

          <t>An alternative would be to combine ECN with the BBR approach,
          which induces a much less noisy delay signal by using less frequent
          but more pronounced delay spikes. The approach currently being taken
          is to adapt the chirp length to the degree of noise, so the chirps
          only become longer and/or more pronounced when necessary, for
          instance when faced with a discontinuous link technology such as
          WiFi. With multiple chirps per round, the noise can still be
          filtered out by averaging over them all, rather than trying to
          remove noise from each spike. This keeps the 'self-harm' to the
          minimum necessary, and ensures that capacity is always being
          sampled, which removes the risk of going stale.</t>
        </section>
      </section>

      <section anchor="pracc_fallback_ecn" title="Fall-Back on Classic ECN">
        <t>The implementation of TCP Prague CC in Linux includes an algorithm
        to detect a Classic ECN AQM and fall back to Reno as a result, as
        required by the 'Coexistence with Classic ECN' aspect of the Prague
        Req 4.3. <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>.</t>

        <t>The algorithm currently used (v2) is relatively simple, but rather
        than describe it here, full rationale, pseudocode and explanation can
        be found in the technical report about it <xref
        target="ecn-fallback"/>. This also includes a selection of the
        evaluation results and a link to visualizations of the full results
        online. The current algorithm nearly always detects a Classic ECN AQM,
        and in the majority of the wide range of scenarios tested it is good
        at detecting an L4S AQM. However, it wrongly identifies and L4S AQM as
        Classic in a significant minority of cases when the link rate is low,
        or the RTT is high. The report gives ideas on how to improve detection
        in these scenarios, but in the mean time the algorithm has been
        disabled by default.</t>

        <t>Recently, the report has been updated to include new ideas on other
        ways to distinguish Classic from L4S AQMs. The interested reader can
        access it themselves, so this living document will not be further
        summarized here.</t>
      </section>

      <section anchor="pracc_further_rtt_independence"
               title="Further Reduced RTT-Dependence">
        <t>The algorithm to reduce RTT dependence is only relevant for
        long-running flows. So in the current TCP Prague implementation it
        remains disabled for a certain number of round trips after the start
        of a flow, as explained in <xref target="pracc_rtt_independence"/>. It
        would be possible to make rtt_virt gradually move from the actual RTT
        to the target virtual RTT, or perhaps depend on other parameters of
        the flow. Nonetheless, just switching in the algorithm after a number
        of rounds works well enough. It is planned to also disable the
        algorithm for a similar duration if a flow becomes idle then restarts,
        but this is yet to be evaluated.</t>

        <t>Prague Req 4.3. in <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>) only
        requires reduced RTT bias "in the range between the minimum likely RTT
        and typical RTTs expected in the intended deployment scenario". The
        current TCP Prague implementation satisfies this requirement (<xref
        target="pracc_rtt_independence"/>). Nonetheless, it would be
        preferable to be able to reduce the RTT bias for high RTT flows as
        well.</t>

        <t>If a step AQM is used, the congestion episodes of flows with
        different RTTs tend to synchronize, which exacerbates RTT bias. To
        prevent this two candidate approaches will need to be investigated: i)
        It might be sufficient to deprecate step AQMs for L4S (they are not
        the preferred recommendation in <xref
        target="I-D.ietf-tsvwg-aqm-dualq-coupled"/>); or ii) the virtual RTT
        approach of <xref target="pracc_rtt_independence"/> might be usable
        for higher than typical RTTs as well as lower. In this latter case,
        (rtt/rtt_virt)^2 segments would need to be added to the window per
        actual RTT. The current TCP Prague implementation does not support
        this faster AI for RTTs longer than RTT_VIRT_MIN (25ms), due to the
        expected (but unverified) impact on latency overshoot and
        responsiveness.</t>
      </section>

      <section anchor="pracc_fractional_windows"
               title="Scaling Down to Fractional Windows">
        <t>A modification to v5.0 of the Linux TCP stack that scales down to
        sub-packet windows is available for research purposes via the L4S
        landing page <xref target="L4S-home"/>. The L4S Prague Requirements in
        section 4.3 of <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/> recommend
        but no longer mandate scaling down to sub-packet windows. This is
        because becoming unresponsive at a minimum window is a tradeoff
        between protecting against other unresponsive flows and the extra
        queue you induce by becoming unresponsive yourself. So this code is
        not maintained as part of the Linux implementation of TCP Prague.</t>

        <t>Firstly, the stack ahs to be modifed to maintain a fractional
        congestion window. The because the ACK clock cannot work below 1
        packet per RTT, the code sets the time to send each packet, then
        readjusts the timing as each ACK arrives (otherwise any queuing
        accumulates a burst in subsequent rounds). Also, additive increase of
        one segment does not scale below a 1-segment window. So instead of a
        constant additive increase, the code uses a logarithmically scaled
        additive increase that slowly adapts the additive increase constant to
        the slow start threshold. Despite these quite radical changes, the
        diff is surprisingly small. The design and implementation is explained
        in <xref target="Ahmed19"/>, which also includes evaluation
        results.</t>
      </section>
    </section>

    <section anchor="pracc_IANA" title="IANA Considerations">
      <t>This specification contains no IANA considerations.</t>
    </section>

    <section anchor="pracc_Security_Considerations"
             title="Security Considerations">
      <t><xref target="pracc_fractional_windows"/> on scaling down to
      fractional windows discusses the tradeoff in becoming unresponsive at a
      minium window, which causes a queue to build (harm to self and to
      others) but protects oneself against other unresponsive flows (whether
      malicious or accidental).</t>

      <t>This draft inherits the security considerations discussed in <xref
      target="I-D.ietf-tsvwg-ecn-l4s-id"/> and in the L4S architecture <xref
      target="I-D.ietf-tsvwg-l4s-arch"/>. In particular, the self-interest
      incentive to be responsive and minimize queuing delay, and protections
      against those interested in disrupting the low queuing delay of
      others.</t>
    </section>

    <section title="Acknowledgements">
      <t>Bob Briscoe's contribution was part-funded by the Comcast Innovation
      Fund. The views expressed here are solely those of the authors.</t>
    </section>

    <section title="Comments and Contributions Solicited (To be removed before Publication)">
      <t>Comments and questions are encouraged and very welcome. They can be
      addressed to the IRTF Internet Congestion Control Research Group's
      mailing list &lt;iccrg@irtf.org&gt;, and/or to the authors via
      &lt;draft-briscoe-iccrg-congestion-control@ietf.org&gt;. Contributions
      of design ideas and/or code are also encouraged and welcome.</t>
    </section>

    <section title="Contributors">
      <t>The following contributed implementations and evaluations that
      validated and helped to improve this specification:<list style="empty">
          <t>Olivier Tilmans &lt;olivier.tilmans@nokia-bell-labs.com&gt; of
          Nokia Bell Labs, Belgium, prepared and maintains the Linux
          implementation of TCP Prague.</t>

          <t>Koen De Schepper &lt;koen.de_schepper@nokia-bell-labs.com&gt; of
          Nokia Bell Labs, Belgium, contributed to the Linux implementation of
          TCP Prague.</t>

          <t>Joakim Misund &lt;joakim.misund@gmail.com&gt; of Uni Oslo,
          Norway, wrote the Linux paced chirping code.</t>

          <t>Asad Sajjad Ahmed &lt;me@asadsa.com&gt;, Independent, Norway,
          wrote the Linux code that maintains a sub-packet window.</t>
        </list></t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>

      <?rfc include='reference.RFC.3168'?>

      <?rfc include='reference.RFC.8311'?>

      <?rfc include='reference.I-D.ietf-tsvwg-ecn-l4s-id'?>

      <?rfc include='reference.I-D.ietf-tcpm-accurate-ecn'?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.RFC.3649'?>

      <?rfc include='reference.RFC.4340'?>

      <?rfc include='reference.RFC.4960'?>

      <?rfc include='reference.RFC.5033'?>

      <?rfc include='reference.RFC.5681'?>

      <?rfc include='reference.RFC.6679'?>

      <?rfc include='reference.RFC.6928'?>

      <?rfc include='reference.RFC.8257'?>

      <?rfc include='reference.RFC.8298'?>

      <?rfc include='reference.I-D.ietf-tsvwg-l4s-arch'?>

      <?rfc include='reference.I-D.ietf-tsvwg-aqm-dualq-coupled'?>

      <?rfc include='reference.I-D.ietf-avtcore-cc-feedback-message'?>

      <?rfc include='reference.I-D.ietf-tcpm-rack'?>

      <?rfc include='reference.I-D.ietf-tcpm-generalized-ecn'?>

      <?rfc include='reference.I-D.ietf-quic-transport'?>

      <?rfc include='reference.I-D.ietf-tcpm-hystartplusplus'?>

      <reference anchor="PragueLinux"
                 target="https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s">
        <front>
          <title>Implementing the `TCP Prague' Requirements for Low Latency
          Low Loss Scalable Throughput (L4S)</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <author fullname="Koen De Schepper" initials="K."
                  surname="De Schepper">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Olga Albisser" initials="O." surname="Albisser">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Joakim Misund" initials="J." surname="Misund">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Mirja K&uuml;hlewind" initials="M."
                  surname="K&uuml;hlewind">
            <organization>ETH Zurich</organization>
          </author>

          <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
            <organization>Simula Research Lab</organization>
          </author>

          <date month="March" year="2019"/>
        </front>

        <seriesInfo name="Proc. Linux Netdev 0x13" value=""/>

        <format target="https://www.files.netdevconf.org/f/4d6939d5f1fb404fafd1/?dl=1"
                type="PDF"/>
      </reference>

      <reference anchor="PerAckEWMA" target="https://arxiv.org/abs/2101.07727">
        <front>
          <title>Improving DCTCP/Prague Congestion Control
          Responsiveness</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <date day="20" month="January" year="2021"/>
        </front>

        <seriesInfo name="Technical Report" value="TR-BB-2020-002"/>

        <format target="https://arxiv.org/pdf/2101.07727" type="PDF"/>
      </reference>

      <reference anchor="patch-alpha-zero"
                 target="https://github.com/torvalds/linux/commits/master/net/ipv4/tcp_dctcp.c">
        <front>
          <title>tcp: allow dctcp alpha to drop to zero</title>

          <author fullname="Andrew G. Shewmaker" initials="A. G. "
                  surname="Shewmaker">
            <organization/>
          </author>

          <date day="23" month="October" year="2015"/>
        </front>

        <seriesInfo name="Linux GitHub patch;" value="Commit: c80dbe0"/>

        <format target="https://github.com/torvalds/linux/commit/c80dbe04612986fd6104b4a1be21681b113b5ac9"
                type="HTML"/>
      </reference>

      <reference anchor="patch-loss-react"
                 target="https://github.com/torvalds/linux/commits/master/net/ipv4/tcp_dctcp.c">
        <front>
          <title>tcp: Ensure DCTCP reacts to losses</title>

          <author fullname="Koen De Schepper" initials="K. "
                  surname="De Schepper">
            <organization/>
          </author>

          <date day="4" month="April" year="2019"/>
        </front>

        <seriesInfo name="Linux GitHub patch;" value="Commit: aecfde2"/>

        <format target="https://github.com/torvalds/linux/commit/aecfde23108b8e637d9f5c5e523b24fb97035dc3"
                type="HTML"/>
      </reference>

      <reference anchor="Tensions17" target="https://arxiv.org/abs/1904.07605">
        <front>
          <title>Resolving Tensions between Congestion Control Scaling
          Requirements</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization/>
          </author>

          <author fullname="Koen De Schepper" initials="K. "
                  surname="De Schepper">
            <organization/>
          </author>

          <date month="July" year="2017"/>
        </front>

        <seriesInfo name="Simula Technical Report"
                    value="TR-CS-2016-001; arXiv:1904.07605"/>

        <format target="https://arxiv.org/pdf/1904.07605" type="PDF"/>
      </reference>

      <reference anchor="L4S-home" target="https://riteproject.eu/dctth/#code">
        <front>
          <title>L4S: Ultra-Low Queuing Delay for All</title>

          <author>
            <organization/>
          </author>

          <date day="" month="" year=""/>
        </front>

        <format target="https://riteproject.eu/dctth/" type="HTML"/>
      </reference>

      <reference anchor="linux-code" target="https://github.com/L4STeam/linux">
        <front>
          <title>Linux kernel tree with L4S patches</title>

          <author>
            <organization/>
          </author>

          <date day="" month="" year=""/>
        </front>

        <format target="https://riteproject.eu/dctth/" type="HTML"/>
      </reference>

      <reference anchor="LinuxPacedChirping"
                 target="https://www.netdevconf.org/0x13/session.html?talk-chirp">
        <front>
          <title>Paced Chirping - Rethinking TCP start-up</title>

          <author fullname="Joakim Misund" initials="J." surname="Misund">
            <organization>University of Oslo</organization>
          </author>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <date month="March" year="2019"/>
        </front>

        <seriesInfo name="Proc. Linux Netdev 0x13" value=""/>

        <format target="https://www.files.netdevconf.info/f/da8cc04a608a448f890e/?dl=1"
                type="PDF"/>
      </reference>

      <reference anchor="ecn-fallback"
                 target="https://arxiv.org/abs/1911.00710">
        <front>
          <title>TCP Prague Fall-back on Detection of a Classic ECN
          AQM</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
            <organization>Simula and Uni Oslo</organization>
          </author>

          <date month="April" year="2020"/>
        </front>

        <seriesInfo name="bobbriscoe.net Technical Report"
                    value="TR-BB-2019-002"/>

        <format target="https://arxiv.org/abs/1911.00710" type="PDF"/>
      </reference>

      <reference anchor="Ahmed19"
                 target="https://www.duo.uio.no/handle/10852/70966">
        <front>
          <title>Extending TCP for Low Round Trip Delay</title>

          <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
            <organization>Simula and Uni Oslo</organization>
          </author>

          <date month="August" year="2019"/>
        </front>

        <seriesInfo name="Masters Thesis, Uni Oslo" value=""/>

        <format target="https://www.duo.uio.no/bitstream/handle/10852/70966/main.pdf?sequence=5&amp;isAllowed=y"
                type="PDF"/>
      </reference>

      <!-- <reference anchor="BIC" target="DOI: 10.1109/INFCOM.2004.1354672">
        <front>
          <title>Binary Increase Congestion Control for Fast Long-Distance
          Networks</title>

          <author fullname="Lisong Xu" initials="L." surname="Xu">
            <organization/>
          </author>

          <author fullname="Khaled Harfoush" initials="K." surname="Harfoush">
            <organization/>

           </author>

          <author fullname="Injong Rhee" initials="I." surname="Rhee">
            <organization/>

          </author>

          <date month="March" year="2004"/>
        </front>

        <seriesInfo name="Proc. IEEE Infocom'04" value="4(2514-2524)"/>

        <format target="https://ieeexplore.ieee.org/document/1354672"
                type="PDF"/>
      </reference>
      -->
    </references>

    <!--
<section title="{ToDo}">
      <t>Delete if not needed.</t>
    </section>

    <section title="Open Issues">
      <t>Minor open issues are tagged '{ToDo}' at the appropriate point in the
      document. Major open issues are listed below:<list>
          <t>None</t>
        </list></t>
    </section>

    <section title="Change Log (to be Deleted before Publication)">
      <t>A detailed version history can be accessed at
      &lt;http://datatracker.ietf.org/doc/draft-briscoe-aqm-ecn-roadmap/history/&gt;</t>

      <t><list style="hanging">
          <t hangText="From briscoe-...-00 to briscoe-...-01:">Technical
          changes:<list style="symbols">
              <t/>
            </list>Editorial changes:<list style="symbols">
              <t/>
            </list></t>
        </list></t>
    </section>
-->
  </back>
</rfc>
